---
title: "HMM Bootstrap with tsbs()"
subtitle: "Regime-Switching Bootstrap for Financial Time Series"
author: "tsbs Package"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
    fig_width: 10
    fig_height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.align = "center"
)
```

## Overview

This vignette demonstrates how to use `tsbs()` with `bs_type = "hmm"` for 
Hidden Markov Model bootstrap of financial time series. The HMM bootstrap is 
particularly useful for data exhibiting regime-switching behavior, such as:

- Bull/bear market cycles
- High/low volatility regimes
- Different economic states

The extended HMM bootstrap in tsbs supports:

1. **Gaussian HMM** (default) - Original behavior via depmixS4
2. **MSGARCH-based HMM** - GARCH dynamics with flexible distributions
3. **Raw HMM** - Non-Gaussian emissions without GARCH

## Setup

```{r load-packages}
library(tsbs)
library(ggplot2)

# Check optional dependencies
has_msgarch <- requireNamespace("MSGARCH", quietly = TRUE)
has_fgarch <- requireNamespace("fGarch", quietly = TRUE)
has_depmix <- requireNamespace("depmixS4", quietly = TRUE)

cat("Available backends:\n")
cat("- depmixS4 (Gaussian HMM):", has_depmix, "\n")
cat("- MSGARCH (GARCH + flexible distributions):", has_msgarch, "\n")
cat("- fGarch (raw HMM with skew-t):", has_fgarch, "\n")
```

## Simulating Regime-Switching Data

We create test data with clear regime structure - a common pattern in financial 
markets with distinct bull and bear regimes.

```{r simulate-data}
# Use parameters known to work well with MSGARCH estimation
set.seed(42)
n <- 300
n1 <- 150
n2 <- 150

# Gaussian regime-switching returns
# State 1 (Bull): Positive drift, low volatility
# State 2 (Bear): Negative drift, high volatility
y_returns <- c(
  rnorm(n1, mean = 0.02, sd = 0.01),
  rnorm(n2, mean = -0.01, sd = 0.03)
)

# Multivariate data with common market factor
set.seed(42)
k <- 3
market_factor <- c(
  rnorm(n1, mean = 0.02, sd = 0.01),
  rnorm(n2, mean = -0.01, sd = 0.03)
)
Y_multi <- matrix(0, nrow = n, ncol = k)
for (j in 1:k) {
  Y_multi[, j] <- market_factor + rnorm(n, sd = 0.002)
}
colnames(Y_multi) <- c("Stock_A", "Stock_B", "Stock_C")
```

```{r plot-data, fig.height=6}
par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))

# Univariate returns
plot(y_returns, type = "l", col = "steelblue",
     main = "Simulated Regime-Switching Returns",
     xlab = "Time", ylab = "Returns")
abline(v = n1, col = "red", lty = 2, lwd = 2)
legend("topright", c("Returns", "Regime Change"), 
       col = c("steelblue", "red"), lty = c(1, 2), bty = "n")

# Multivariate returns
matplot(Y_multi, type = "l", lty = 1, col = 2:4,
        main = "Multivariate Returns (Common Factor Structure)",
        xlab = "Time", ylab = "Returns")
abline(v = n1, col = "red", lty = 2, lwd = 2)
legend("topright", colnames(Y_multi), col = 2:4, lty = 1, bty = "n")

par(mfrow = c(1, 1))
```

## 1. Basic Gaussian HMM Bootstrap

The default `distribution = "gaussian"` uses depmixS4 for HMM fitting. This is 
the original behavior and requires only the depmixS4 package.

```{r gaussian-basic, eval=has_depmix}
# Basic HMM bootstrap with Gaussian emissions
result_gaussian <- tsbs(
  x = y_returns,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 100,
  func = mean  # Compute mean of each replicate
)

cat("Number of bootstrap replicates:", length(result_gaussian$bootstrap_series), "\n")
cat("Length of each replicate:", nrow(result_gaussian$bootstrap_series[[1]]), "\n")
```

### Analyzing Bootstrap Results

```{r gaussian-analysis, eval=has_depmix, fig.height=5}
# Extract statistics from bootstrap replicates
boot_means <- sapply(result_gaussian$bootstrap_series, mean)
boot_sds <- sapply(result_gaussian$bootstrap_series, sd)
boot_skews <- sapply(result_gaussian$bootstrap_series, function(x) {
  mean((x - mean(x))^3) / sd(x)^3
})

# Summary statistics
cat("\nBootstrap Mean Distribution:\n")
cat("  Original mean:", round(mean(y_returns), 5), "\n")
cat("  Bootstrap mean of means:", round(mean(boot_means), 5), "\n")
cat("  Bootstrap SE of mean:", round(sd(boot_means), 5), "\n")
cat("  95% CI:", round(quantile(boot_means, c(0.025, 0.975)), 5), "\n")

# Visualize
par(mfrow = c(1, 3))

hist(boot_means, breaks = 25, col = "steelblue", border = "white",
     main = "Bootstrap Distribution of Mean", xlab = "Mean", probability = TRUE)
abline(v = mean(y_returns), col = "red", lwd = 2)
abline(v = quantile(boot_means, c(0.025, 0.975)), col = "darkgreen", lty = 2)

hist(boot_sds, breaks = 25, col = "coral", border = "white",
     main = "Bootstrap Distribution of SD", xlab = "Standard Deviation", probability = TRUE)
abline(v = sd(y_returns), col = "red", lwd = 2)

hist(boot_skews, breaks = 25, col = "mediumpurple", border = "white",
     main = "Bootstrap Distribution of Skewness", xlab = "Skewness", probability = TRUE)
abline(v = 0, col = "red", lwd = 2)

par(mfrow = c(1, 1))
```

## 2. Using Diagnostics

The `tsbs()` function can return detailed diagnostics about the bootstrap 
procedure when `return_diagnostics = TRUE`.

```{r diagnostics-basic, eval=has_depmix}
# Run with diagnostics enabled
result_diag <- tsbs(
  x = y_returns,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 50,
  return_diagnostics = TRUE
)

# Check what's returned
cat("Result components:", names(result_diag), "\n")
```

### Summary of Diagnostics

```{r diagnostics-summary, eval=has_depmix}
if (!is.null(result_diag$diagnostics)) {
  # Print summary
  summary(result_diag$diagnostics)
}
```

### Visualizing Bootstrap Quality

```{r diagnostics-plots, eval=has_depmix, fig.height=8}
if (!is.null(result_diag$diagnostics)) {
  # Plot diagnostics
  plot(result_diag$diagnostics)
}
```

### Comparing Original vs Bootstrap Statistics

```{r compare-stats, eval=has_depmix, fig.height=5}
if (!is.null(result_diag$diagnostics)) {
  diag <- result_diag$diagnostics
  
  # Extract replicate statistics
  rep_means <- unlist(diag$series_stats$replicate_means)
  rep_sds <- unlist(diag$series_stats$replicate_sds)
  rep_ac1 <- unlist(diag$series_stats$replicate_ac1)
  
  # Original statistics
  orig_mean <- diag$original_stats$means
  orig_sd <- diag$original_stats$sds
  orig_ac1 <- diag$original_stats$ac1
  
  par(mfrow = c(1, 3))
  
  # Mean comparison
  hist(rep_means, breaks = 20, col = "lightblue", border = "white",
       main = "Mean: Bootstrap vs Original", xlab = "Mean")
  abline(v = orig_mean, col = "red", lwd = 2)
  legend("topright", "Original", col = "red", lwd = 2, bty = "n")
  
  # SD comparison
  hist(rep_sds, breaks = 20, col = "lightgreen", border = "white",
       main = "SD: Bootstrap vs Original", xlab = "Standard Deviation")
  abline(v = orig_sd, col = "red", lwd = 2)
  
  # Autocorrelation comparison
  hist(rep_ac1, breaks = 20, col = "lightyellow", border = "white",
       main = "AC(1): Bootstrap vs Original", xlab = "Lag-1 Autocorrelation")
  abline(v = orig_ac1, col = "red", lwd = 2)
  
  par(mfrow = c(1, 1))
}
```

## 3. MSGARCH-Based HMM Bootstrap

When MSGARCH is available, you can use distributions that capture heavy tails 
and skewness common in financial returns.

### Normal Distribution with GARCH Dynamics

```{r msgarch-norm, eval=has_msgarch}
# MSGARCH with normal distribution and sGARCH dynamics
result_msgarch <- tsbs(
  x = y_returns,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 100,
  distribution = "norm",
  variance_model = "sGARCH",
  seed = 123
)

cat("MSGARCH bootstrap completed\n")
cat("Number of replicates:", length(result_msgarch$bootstrap_series), "\n")
```

### Skew Student-t Distribution

The skew Student-t distribution (`distribution = "sstd"`) captures both heavy 
tails and asymmetry - two stylized facts of financial returns.

```{r msgarch-sstd, eval=has_msgarch && has_fgarch}
# Generate skew-t data for demonstration
set.seed(42)
y_sstd <- c(
  fGarch::rsstd(150, mean = 0.02, sd = 0.01, nu = 10, xi = 1.2),
  fGarch::rsstd(150, mean = -0.01, sd = 0.03, nu = 6, xi = 0.8)
)

# MSGARCH with skew Student-t
result_sstd <- tsbs(
  x = y_sstd,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 100,
  distribution = "sstd",
  variance_model = "sGARCH",
  seed = 123
)

cat("Skew-t MSGARCH bootstrap completed\n")
```

### Comparing Distributions

```{r compare-distributions, eval=has_msgarch, fig.height=5}
# Compare bootstrap distributions from different methods
results_list <- list()

if (has_depmix) {
  results_list$Gaussian <- result_gaussian$bootstrap_series
}
results_list$MSGARCH_norm <- result_msgarch$bootstrap_series

# Compute statistics
stats_df <- do.call(rbind, lapply(names(results_list), function(nm) {
  data.frame(
    method = nm,
    mean = sapply(results_list[[nm]], mean),
    sd = sapply(results_list[[nm]], sd)
  )
}))

# Plot comparison
par(mfrow = c(1, 2))

boxplot(mean ~ method, data = stats_df, col = c("steelblue", "coral")[1:length(unique(stats_df$method))],
        main = "Bootstrap Means by Method", ylab = "Mean")
abline(h = mean(y_returns), col = "red", lty = 2)

boxplot(sd ~ method, data = stats_df, col = c("steelblue", "coral")[1:length(unique(stats_df$method))],
        main = "Bootstrap SDs by Method", ylab = "Standard Deviation")
abline(h = sd(y_returns), col = "red", lty = 2)

par(mfrow = c(1, 1))
```

## 4. Raw HMM Bootstrap (No GARCH)

For simpler models without GARCH dynamics, use the `"_raw"` distribution variants.

```{r raw-hmm, eval=TRUE}
# Raw HMM with normal emissions (no GARCH)
result_raw <- tsbs(
  x = y_returns,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 100,
  distribution = "norm_raw",
  seed = 123
)

cat("Raw HMM bootstrap completed\n")
cat("Number of replicates:", length(result_raw$bootstrap_series), "\n")
```

## 5. Multivariate Bootstrap

For multivariate data, `tsbs()` uses synchronized sampling to preserve 
cross-sectional dependence.

```{r multivariate, eval=has_msgarch}
# Multivariate HMM bootstrap
result_multi <- tsbs(
  x = Y_multi,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 50,
  distribution = "norm",
  regime_basis = "market",  # Use equal-weighted average for regime identification
  seed = 123
)

cat("Multivariate bootstrap completed\n")
cat("Dimensions of first replicate:", dim(result_multi$bootstrap_series[[1]]), "\n")
```

### Cross-Sectional Dependence Preservation

```{r multivariate-corr, eval=has_msgarch, fig.height=5}
# Compare correlations: original vs bootstrap
orig_cor <- cor(Y_multi)

# Compute correlation for each bootstrap replicate
boot_cors <- lapply(result_multi$bootstrap_series, cor)

# Average bootstrap correlation
avg_boot_cor <- Reduce(`+`, boot_cors) / length(boot_cors)

cat("Original Correlation Matrix:\n")
print(round(orig_cor, 3))

cat("\nAverage Bootstrap Correlation Matrix:\n")
print(round(avg_boot_cor, 3))

cat("\nDifference (Bootstrap - Original):\n")
print(round(avg_boot_cor - orig_cor, 4))
```

## 6. Applying Custom Functions

Use the `func` parameter to compute statistics on each bootstrap replicate.

```{r custom-func, eval=has_depmix}
# Define a custom function: Sharpe ratio (annualized)
sharpe_ratio <- function(x) {
  mean(x) / sd(x) * sqrt(252)
}

# Bootstrap the Sharpe ratio
result_sharpe <- tsbs(
  x = y_returns,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 500,
  func = sharpe_ratio
)

# Analyze results
sharpe_values <- unlist(result_sharpe$func_outs)
original_sharpe <- sharpe_ratio(y_returns)

cat("Sharpe Ratio Analysis:\n")
cat("  Original Sharpe:", round(original_sharpe, 3), "\n")
cat("  Bootstrap Mean:", round(mean(sharpe_values), 3), "\n")
cat("  Bootstrap SE:", round(sd(sharpe_values), 3), "\n")
cat("  95% CI:", round(quantile(sharpe_values, c(0.025, 0.975)), 3), "\n")
```

```{r sharpe-plot, eval=has_depmix, fig.height=4}
hist(sharpe_values, breaks = 30, col = "steelblue", border = "white",
     main = "Bootstrap Distribution of Sharpe Ratio",
     xlab = "Annualized Sharpe Ratio", probability = TRUE)
abline(v = original_sharpe, col = "red", lwd = 2)
abline(v = quantile(sharpe_values, c(0.025, 0.975)), col = "darkgreen", lty = 2, lwd = 2)
legend("topright", c("Original", "95% CI"), col = c("red", "darkgreen"), 
       lty = c(1, 2), lwd = 2, bty = "n")
```

## 7. Advanced: Multiple Statistics

For multivariate analysis, compute multiple statistics simultaneously.

```{r multi-stats, eval=has_depmix}
# Function returning multiple portfolio statistics
portfolio_stats <- function(x) {
  weights <- rep(1/ncol(x), ncol(x))  # Equal weight
  port_ret <- as.vector(x %*% weights)
  
  list(
    mean_return = mean(port_ret),
    volatility = sd(port_ret),
    sharpe = mean(port_ret) / sd(port_ret) * sqrt(252),
    max_drawdown = max(cummax(cumsum(port_ret)) - cumsum(port_ret))
  )
}

# Bootstrap portfolio statistics
result_portfolio <- tsbs(
  x = Y_multi,
  bs_type = "hmm",
  num_states = 2,
  num_boots = 200,
  func = portfolio_stats,
  apply_func_to = "all"
)

# Extract and summarize
stats_names <- names(result_portfolio$func_outs[[1]])
cat("Portfolio Statistics Bootstrap Results:\n\n")

for (stat in stats_names) {
  values <- sapply(result_portfolio$func_outs, `[[`, stat)
  cat(sprintf("%-15s Mean: %8.4f  SE: %8.4f  95%% CI: [%8.4f, %8.4f]\n",
              paste0(stat, ":"),
              mean(values), sd(values),
              quantile(values, 0.025), quantile(values, 0.975)))
}
```

## 8. Distribution Reference

| Distribution | Backend | GARCH | Heavy Tails | Skewness | Use Case |
|-------------|---------|-------|-------------|----------|----------|
| `"gaussian"` | depmixS4 | No | No | No | Simple regime-switching |
| `"norm"` | MSGARCH | Yes | No | No | Volatility clustering |
| `"std"` | MSGARCH | Yes | Yes | No | Fat-tailed returns |
| `"sstd"` | MSGARCH | Yes | Yes | Yes | Asymmetric fat tails |
| `"snorm"` | MSGARCH | Yes | No | Yes | Asymmetric returns |
| `"ged"` | MSGARCH | Yes | Yes | No | Flexible tail weight |
| `"sged"` | MSGARCH | Yes | Yes | Yes | Full flexibility |
| `"norm_raw"` | EM | No | No | No | Simple, no GARCH |
| `"std_raw"` | EM/fGarch | No | Yes | No | Fat tails, no GARCH |
| `"sstd_raw"` | EM/fGarch | No | Yes | Yes | Skew-t, no GARCH |

## Summary

Key takeaways for using HMM bootstrap with `tsbs()`:

1. **Default behavior** (`distribution = "gaussian"`) is backward compatible and 
   requires only depmixS4

2. **MSGARCH distributions** add GARCH dynamics - use for data with volatility 
   clustering

3. **Raw distributions** (`"_raw"` suffix) are simpler models without GARCH

4. **Multivariate data** uses synchronized sampling via `regime_basis` parameter

5. **Diagnostics** (`return_diagnostics = TRUE`) help assess bootstrap quality

6. **Custom functions** allow bootstrapping any statistic of interest

## Session Info

```{r session-info}
sessionInfo()
```
