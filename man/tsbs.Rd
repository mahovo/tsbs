% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsbs.R
\name{tsbs}
\alias{tsbs}
\title{Flexible Block Bootstrap for Time Series}
\usage{
tsbs(
  x,
  n_boot = NULL,
  block_length = NULL,
  bs_type = c("moving", "stationary", "hmm", "msar", "wild"),
  block_type = c("overlapping", "non-overlapping", "tapered"),
  taper_type = c("cosine", "bartlett", "tukey"),
  tukey_alpha = 0.5,
  num_blocks = NULL,
  num_boots = 100L,
  func = mean,
  apply_func_to = c("cols", "df"),
  p_method = c("1/n", "plugin", "cross validation"),
  p = NULL,
  overlap = TRUE,
  ar_order = 1,
  num_states = 2L,
  model_func = default_model_func,
  score_func = mse,
  stationary_max_percentile = 0.99,
  stationary_max_fraction_of_n = 0.1,
  parallel = FALSE,
  num_cores = 1L
)
}
\arguments{
\item{x}{Numeric vector, matrix, or data frame of time series observations
(rows = time points, cols = variables).}

\item{n_boot}{Integer, optional desired length of each bootstrap replicate.}

\item{block_length}{Integer length of each block; if \code{NULL}, an automatic
heuristic is used. For stationary bootstrap, \code{block_length} is the expected
block length, when \code{p_method="1/n"}.}

\item{bs_type}{Bootstrap type. Character string: One of \code{"moving"},
\code{"stationary"}, \code{"hmm"}, \code{"msar"}, or \code{"wild"}. See details below.}

\item{block_type}{Block type. Character string: One of \code{"non-overlapping"},
\code{"overlapping"}, or \code{"tapered"}. Only affects \code{bs_type="moving"} and
\code{bs_type="stationary"}. \code{block_type="tapered"} will smooth out transitions
between blocks. It follows that \code{block_type="tapered"} can not be used when
\code{block_length=1}.}

\item{taper_type}{Tapering window function. Character. One of \code{"cosine"},
\code{"bartlett"}, or \code{"tukey"}.}

\item{num_blocks}{Integer number of blocks per bootstrap replicate.}

\item{num_boots}{Integer number of bootstrap replicates.}

\item{func}{A summary function to apply to each bootstrap replicate or column.}

\item{apply_func_to}{Character string: \code{"cols"} to apply columnwise or \code{"df"}
to apply on the full data frame.}

\item{p_method}{Character string to choose method for stationary bootstrap
parameter: \code{"1/n"}, \code{"plugin"}, or \code{"cross validation"}.}

\item{p}{Optional numeric value for stationary bootstrap \code{p}.}

\item{overlap}{Logical indicating if overlapping blocks are allowed.}

\item{ar_order}{Integer AR order for MSAR (\code{bs_type="msar"}).}

\item{num_states}{Integer number of states for HMM or MSAR.}

\item{model_func}{Model-fitting function for cross-validation.}

\item{score_func}{Scoring function for cross-validation.}

\item{stationary_max_percentile}{Stationary max percentile.}

\item{stationary_max_fraction_of_n}{Stationary max fraction of n.}

\item{parallel}{Parallelize computation? \code{TRUE} or \code{FALSE}.}

\item{num_cores}{Number of cores.}
}
\value{
A list containing:
\describe{
\item{bootstrap_series}{List of bootstrap replicate matrices.}
\item{func_outs}{List of computed function outputs for each replicate.}
\item{func_out_means}{Mean of the computed outputs across replicates.}
}
}
\description{
Generates block bootstrap replicates of a numeric time series or multivariate
time series. Supports moving, stationary, HMM, MSAR, and wild bootstrap types.
}
\examples{
set.seed(123)
x <- arima.sim(n = 100, list(ar = 0.8))
result <- tsbs(
  x = x,
  block_length = 10,
  bs_type = "stationary",
  num_blocks = 5,
  num_boots = 10,
  func = mean,
  apply_func_to = "cols"
)
print(result$func_out_means)

}
