% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsbs.R
\name{tsbs}
\alias{tsbs}
\title{Flexible Block Bootstrap for Time Series}
\usage{
tsbs(
  x,
  n_boot = NULL,
  block_length = NULL,
  bs_type = c("moving", "stationary", "hmm", "msar", "ms_varma_garch", "wild"),
  block_type = c("overlapping", "non-overlapping", "tapered"),
  taper_type = c("cosine", "bartlett", "tukey"),
  tukey_alpha = 0.5,
  num_blocks = NULL,
  num_boots = 100L,
  func = mean,
  apply_func_to = c("cols", "df"),
  p_method = c("1/n", "plugin", "cross validation"),
  p = NULL,
  overlap = TRUE,
  num_states = 2L,
  d = 0,
  spec = NULL,
  model_type = c("univariate", "multivariate"),
  control = list(),
  parallel = FALSE,
  num_cores = 1L,
  ...
)
}
\arguments{
\item{x}{Numeric vector, matrix, or data frame of time series observations
(rows = time points, cols = variables).}

\item{n_boot}{Integer, optional desired length of each bootstrap replicate.}

\item{block_length}{Integer length of each block; if \code{NULL}, an automatic
heuristic is used. For stationary bootstrap, \code{block_length} is the expected
block length, when \code{p_method="1/n"}.}

\item{bs_type}{Bootstrap type. Character string: One of \code{"moving"},
\code{"stationary"}, \code{"hmm"}, \code{"msar"}, \code{"ms_varma_garch"}, or \code{"wild"}. See details below.}

\item{block_type}{Block type. Character string: One of \code{"non-overlapping"},
\code{"overlapping"}, or \code{"tapered"}. Only affects \code{bs_type="moving"} and
\code{bs_type="stationary"}. \code{block_type="tapered"} will smooth out transitions
between blocks. It follows that \code{block_type="tapered"} can not be used when
\code{block_length=1}.}

\item{taper_type}{Tapering window function. Character. One of \code{"cosine"},
\code{"bartlett"}, or \code{"tukey"}.}

\item{num_blocks}{Integer number of blocks per bootstrap replicate.}

\item{num_boots}{Integer number of bootstrap replicates.}

\item{func}{A summary function to apply to each bootstrap replicate or column.}

\item{apply_func_to}{Character string: \code{"cols"} to apply columnwise or \code{"df"}
to apply on the full data frame.}

\item{p_method}{Character string to choose method for stationary bootstrap
parameter: \code{"1/n"}, \code{"plugin"}, or \code{"cross validation"}.}

\item{p}{Optional numeric value for stationary bootstrap \code{p}.}

\item{overlap}{Logical indicating if overlapping blocks are allowed.}

\item{num_states}{Integer number of states for HMM, MSAR, or
MS-VARMA-GARCH models.}

\item{d}{Integer differencing order for the MS-VARMA-GARCH model.}

\item{spec}{A list defining the state-specific models for the MS-VARMA-GARCH
bootstrap (bs_type = "ms_varma_garch"). This argument is required for
this bootstrap type and must be a list of length num_states. Each element
of the list is itself a list specifying the model for that state. The
structure depends on whether the model is univariate or multivariate.

\strong{For univariate models (one-column x):}
Each element spec[\link{j}] must be a list with the following components. For a
complete list of all possible arguments (e.g., for different GARCH model
flavors), please refer to the documentation for tsgarch::garch_modelspec.
\itemize{
\item \code{arma_order}: A numeric vector c(p,q) for the ARMA(p,q) order.
\item \code{garch_model}: A character string for the GARCH model type
(e.g., "garch", "egarch").
\item \code{garch_order}: A numeric vector c(g,h) for the GARCH(g,h) order.
\item \code{distribution}: A character string for the conditional
distribution (e.g., "norm", "std").
\item \code{start_pars}: A list containing the starting parameters for
the optimization, with two named elements:
\itemize{
\item \code{arma_pars}: A named numeric vector for the ARMA parameters
(e.g., c(ar1 = 0.5)).
\item \code{garch_pars}: A named list for the GARCH parameters (e.g.,
list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8)).
}
}

\strong{For multivariate models (multi-column x):}
Each element spec[\link{j}] must be a list with the following components. For a
complete list of all possible arguments, please refer to the documentation
for the relevant tsmarch specification function (e.g., ?tsmarch::dcc_modelspec).
\itemize{
\item \code{var_order}: An integer p for the VAR(p) order.
\item \code{garch_spec_fun}: A character string with the name of the
tsmarch specification function to use (e.g., "dcc_modelspec",
"gogarch_modelspec").
\item \code{garch_spec_args}: A list of arguments to pass to the function
specified in garch_spec_fun. Key arguments include:
\itemize{
\item \code{distribution}: The multivariate distribution. Valid
choices are "mvn" (for multivariate normal) and "mvt" (for
multivariate Student's t).
\item For models like DCC or CGARCH, this list must also contain a
\code{garch_model} definition for the underlying univariate GARCH
fits.
}
\item \code{start_pars}: A list containing the starting parameters, with
two named elements:
\itemize{
\item \code{var_pars}: A numeric vector for the VAR parameters,
stacked column by column (intercept, lags for eq1, intercept, lags
for eq2, ...).
\item \code{garch_pars}: A named list for the multivariate GARCH
parameters (e.g., list(dcc_alpha = 0.05, dcc_beta = 0.9)).
}
}}

\item{model_type}{Character string for MS-VARMA-GARCH: \code{"univariate"} or
\code{"multivariate"}.}

\item{control}{A list of control parameters for the MS-VARMA-GARCH EM
algorithm.}

\item{parallel}{Parallelize computation? \code{TRUE} or \code{FALSE}.}

\item{num_cores}{Number of cores.}

\item{model_func}{Model-fitting function for cross-validation.}

\item{score_func}{Scoring function for cross-validation.}

\item{stationary_max_percentile}{Stationary max percentile.}

\item{stationary_max_fraction_of_n}{Stationary max fraction of n.}
}
\value{
A list containing:
\describe{
\item{bootstrap_series}{List of bootstrap replicate matrices.}
\item{func_outs}{List of computed function outputs for each replicate.}
\item{func_out_means}{Mean of the computed outputs across replicates.}
}
}
\description{
Generates block bootstrap replicates of a numeric time series or multivariate
time series. Supports moving, stationary, HMM, MSAR, MS VARMA GARCH and wild
bootstrap types.
}
\examples{
set.seed(123)
x <- arima.sim(n = 100, list(ar = 0.8))
result <- tsbs(
  x = x,
  block_length = 10,
  bs_type = "stationary",
  num_blocks = 5,
  num_boots = 10,
  func = mean,
  apply_func_to = "cols"
)
print(result$func_out_means)

}
