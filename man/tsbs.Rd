% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsbs.R
\name{tsbs}
\alias{tsbs}
\title{Advanced Bootstrap for Time Series}
\usage{
tsbs(
  x,
  n_boot = NULL,
  block_length = NULL,
  bs_type = c("moving", "stationary", "hmm", "msvar", "ms_varma_garch", "wild"),
  block_type = c("overlapping", "non-overlapping", "tapered"),
  taper_type = c("cosine", "bartlett", "tukey"),
  tukey_alpha = 0.5,
  num_blocks = NULL,
  num_boots = 100L,
  func = mean,
  apply_func_to = c("cols", "all"),
  p_method = c("1/n", "plugin", "cv"),
  p = NULL,
  overlap = TRUE,
  num_states = 2L,
  d = 0,
  spec = NULL,
  model_type = c("univariate", "multivariate"),
  control = list(),
  parallel = FALSE,
  num_cores = 1L,
  model_func = default_model_func,
  score_func = mse,
  stationary_max_percentile = 0.99,
  stationary_max_fraction_of_n = 0.1,
  return_fit = FALSE,
  fail_mode = c("predictably", "gracefully"),
  ...
)
}
\arguments{
\item{x}{Numeric vector, matrix, data frame or time series observations
(rows = time points, cols = variables).}

\item{n_boot}{Integer, optional desired length of each bootstrap replicate.
See details below.}

\item{block_length}{Integer, length of each block. If \code{NULL}, an automatic
heuristic is used: The method first calculates the average absolute
first-order autocorrelation (\eqn{\rho_1}) across all time series columns.
A candidate block length is then calculated based on this persistence
measure using the formula \eqn{⌊10/(1−\rho_1)⌋}. The final block length is
constrained to be between 5 and the square root of the series length.
For stationary bootstrap, \code{block_length} is the expected block length, when
\code{p_method="1/n"}.}

\item{bs_type}{Bootstrap type. Character string: One of \code{"moving"},
\code{"stationary"}, \code{"hmm"}, \code{"msvar"}, \code{"ms_varma_garch"}, or \code{"wild"}.
\code{"msvar"} is a lightweight special case of \code{"ms_varma_garch"}. See details
below.}

\item{block_type}{Block type. Character string: One of \code{"non-overlapping"},
\code{"overlapping"}, or \code{"tapered"}. Only affects \code{bs_type="moving"} and
\code{bs_type="stationary"}. \code{block_type="tapered"} will smooth out transitions
between blocks. It follows that \code{block_type="tapered"} can not be used when
\code{block_length=1}.}

\item{taper_type}{Tapering window function. Character. One of \code{"cosine"},
\code{"bartlett"}, or \code{"tukey"}. Only affects \code{block_type="tapered"}. See
details below.}

\item{tukey_alpha}{numeric, alpha parameter for \code{taper_type = "tukey"}.
\eqn{\alpha \in [0, 1]} is the fraction of the window length tapered at
each end, using indices \eqn{0 \dots n−1}, where \eqn{n} is the block length.}

\item{num_blocks}{Integer number of blocks per bootstrap replicate.}

\item{num_boots}{Integer number of bootstrap replicates.}

\item{func}{A function to apply to each bootstrap replicate. The function's
expected input depends on the \code{apply_func_to} parameter:
\itemize{
\item If \code{apply_func_to = "cols"}: \code{func} receives a single numeric
vector (one column at a time) and should return a scalar or numeric
vector. Examples: \code{mean}, \code{sd}, \code{quantile}.
\item If \code{apply_func_to = "all"}: \code{func} receives the entire bootstrap
replicate as a numeric matrix (rows = time points, columns = variables)
and can return:
\itemize{
\item A numeric scalar or vector (e.g., portfolio weights)
\item A named list of numeric values (e.g., multiple summary
statistics)
}
Examples: portfolio optimization functions, functions returning
multiple statistics.
}
The function outputs are collected in \code{func_outs} (one entry per
replicate), and \code{func_out_means} contains the element-wise average across
replicates. For list-returning functions, each named element is averaged
separately. Default is \code{mean}.}

\item{apply_func_to}{Character string: \code{"cols"} to apply columnwise or \code{"all"}
to apply on the full data frame or matrix.}

\item{p_method}{Character string to choose method for stationary bootstrap
parameter: \code{"1/n"}, \code{"plugin"}, or \code{"cv"}.}

\item{p}{numeric \eqn{p \in (0, 1)}. Probability parameter for the geometric
block length (used in Stationary Bootstrap).}

\item{overlap}{Logical indicating if overlapping blocks are allowed.}

\item{num_states}{Integer number of states for HMM, MSVAR, or
MS-VARMA-GARCH models.}

\item{d}{Integer differencing order for the MS-VARMA-GARCH model.}

\item{spec}{A list defining the state-specific models for the MS-VARMA-GARCH
bootstrap (bs_type = "ms_varma_garch"). This argument is required for
this bootstrap type and must be a list of length \code{num_states}. Each element
of the list is itself a list specifying the model for that state. The
structure depends on whether the model is univariate or multivariate.
Fitting relies on the tsgarch or tsmarch packages, respectively. See
details below.}

\item{model_type}{Character string for MS-VARMA-GARCH: \code{"univariate"} or
\code{"multivariate"}.}

\item{control}{A list of control parameters for the MS-VARMA-GARCH EM
algorithm.}

\item{parallel}{Parallelize computation? \code{TRUE} or \code{FALSE}.}

\item{num_cores}{Number of cores when \code{parallel=TRUE}.}

\item{model_func}{Model-fitting function for cross-validation.
See \link{k_fold_cv_ts}.}

\item{score_func}{Scoring function for cross-validation.}

\item{stationary_max_percentile}{Stationary max percentile.}

\item{stationary_max_fraction_of_n}{Stationary max fraction of n.}

\item{return_fit}{If \code{TRUE}, \code{tsbs()} will return model fit. Default is
\code{return_fit = FALSE}. If \code{return_fit = TRUE} and
\code{bs_type = "ms_varma_garch"}, diagnostics can be extracted from
\code{result$fit$diagnostics}. See \code{?fit_ms_varma_garch}.}

\item{fail_mode}{Character string. One of \code{"predictably"} (development/
debugging - fail fast on any unexpected behavior) or \code{"gracefully"}
(production/robust pipelines - continue despite validation errors).}
}
\value{
A list containing:
\describe{
\item{bootstrap_series}{List of bootstrap replicate matrices.}
\item{func_outs}{List of computed function outputs for each replicate.}
\item{func_out_means}{Mean of the computed outputs across replicates.}
\item{fit}{If \code{return_fit = TRUE}, a list containing model fit.}
}
}
\description{
Generates bootstrap replicates of multivariate or (multiple) univariate time
series. Supports moving and stationary block, HMM, MSVAR, MS VARMA GARCH and
wild bootstrap types.
}
\details{
\subsection{Bootstrap types}{

See documentation for the individual bootstrap functions:
\itemize{
\item For moving or stationary block bootstraps, see \code{\link[=blockBootstrap]{blockBootstrap()}}
\item \code{\link[=hmm_bootstrap]{hmm_bootstrap()}}
\item \code{\link[=msvar_bootstrap]{msvar_bootstrap()}}
\item \code{\link[=ms_varma_garch_bs]{ms_varma_garch_bs()}}
\item \code{\link[=wild_bootstrap]{wild_bootstrap()}}
}
\subsection{\code{bs_type="moving"}}{

If \code{n_boot} is set, the last block will be truncated when necessary to
match the length (\code{n_boot}) of the bootstrap series. If \code{n_boot} is not
set, \code{block_length} and \code{num_blocks} must be set, and \code{n_boot} will
automatically be set to \code{block_length * num_blocks}.
}

\subsection{\code{bs_type="stationary"}, \code{bs_type="hmm"}, \code{bs_type="msvar"}}{

If \code{n_boot} is set, the last block will be truncated when necessary to
match the length (\code{n_boot}) of the bootstrap series. This is the only way
to ensure equal length of all bootstrap series, as the length of each block
is random. If \code{n_boot} is not set, \code{num_blocks} must be set, and the length
of each bootstrap series will be determined by the number of blocks and the
random lengths of the individual blocks for that particular series. Note
that this typically results in bootstrap series of different lengths. For
stationary bootstrap, \code{block_length} is the expected block length, when
\code{p_method="1/n"}.
}

\subsection{\code{bs_type="wild"}}{

\code{n_boot}, \code{block_length} and \code{num_blocks} are ignored. The length of the
bootstrap series is always the same as the original series.
}

\subsection{\code{bs_type = "ms_varma_garch"}}{

\code{spec} list structure:

\itemize{
\item \strong{For univariate models (one-column x):}
Each element spec[[j]] must be a list with the following components. For a
complete list of all possible arguments (e.g., for different GARCH model
flavors), please refer to the documentation for the tsgarch package
(\code{?tsgarch} and
\code{vignette("garch_models", package = "tsgarch")}).
\itemize{
\item \code{arma_order}: A numeric vector c(p,q) for the ARMA(p,q) order.
\item \code{garch_model}: A character string for the GARCH model type
(e.g., "garch", "egarch").
\item \code{garch_order}: A numeric vector c(g,h) for the GARCH(g,h) order.
\item \code{distribution}: A character string for the conditional
distribution.
\itemize{
\item \code{"norm"} = Normal
\item \code{"snorm"} = Skew normal
\item \code{"std"} = Student t
\item \code{"sstd"} = Skew Student
\item \code{"ged"}  = Generalized error
\item \code{"ged"}  = Skew generalized error
\item \code{"ghyp"}  = Generalized hyperbolic
\item \code{"ghst"}  = Generalized hyperbolic skew Student
\item \code{"jsu"}  = Johnson reparameterized SU
}
See \url{https://www.nopredict.com/packages/tsdistributions}.
\item \code{start_pars}: A list containing the starting parameters for
the optimization, with two named elements:
\itemize{
\item \code{arma_pars}: A named numeric vector for the ARMA parameters
(e.g., c(ar1 = 0.5)).
\item \code{garch_pars}: A named list for the GARCH parameters (e.g.,
list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8)).
\item \code{dist_pars}: A named list for the starting values for
univariate dist params (e.g. list(skew = 1.0, shape = 6.0)).
}
}

\item \strong{For multivariate models (multi-column x):}
Each element spec[[j]] must be a list with the following components. For a
complete list of all possible arguments, please refer to the documentation
for the relevant tsmarch specification function. For a DCC model see
\code{?dcc_modelspec.tsgarch.multi_estimate}, for a Copula GARCH model see
\code{?cgarch_modelspec.tsgarch.multi_estimate}. (See also \code{?tsmarch},
\code{vignette("tsmarch_demo", package = "tsmarch")} and
\code{vignette("feasible_multivariate_garch", package = "tsmarch")}.)
\itemize{
\item \code{var_order}: An integer p for the VAR(p) order.
\item \code{garch_spec_fun}: A character string with the name of the
tsmarch specification function to use (e.g., "dcc_modelspec",
"gogarch_modelspec").
\item \code{distribution}: The multivariate distribution. Valid
choices are "mvn" (for multivariate normal) and "mvt" (for
multivariate Student's t).
\item \code{garch_spec_args}: A list of arguments to pass to the function
specified in garch_spec_fun. Key arguments include:
\itemize{
\item For models like DCC or CGARCH, this list must also contain a
\code{garch_model} definition for the underlying univariate GARCH
fits.
Note: With the exception of the Copula model, the marginal
distributions of the univariate GARCH models should always be
Normal, irrespective of whether a multivariate Normal or Student is
chosen as the DCC model distribution. There are no checks performed
for this and it is up to the user to ensure that this is the case.
}
\item \code{start_pars}: A list containing the starting parameters, with
two named elements:
\itemize{
\item \code{var_pars}: A numeric vector for the VAR parameters,
stacked column by column (intercept, lags for eq1, intercept, lags
for eq2, ...).
\item \code{garch_pars}: A list of named lists for the multivariate
GARCH parameters, e.g.
\code{replicate(k, list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85), simplify = FALSE)}.
\item \code{dcc pars}: A named list, e.g.
\code{list(alpha_1 = 0.05, beta_1 = 0.90)}.
\item \code{dist pars}: A named list, e.g.
\code{list(shape = 8.0)}.
}
}
}
}

\subsection{Diagnostics for MS VARMA GARCH}{

Diagnostic System: A comprehensive diagnostic system monitors
convergence and numerical stability during estimation.
Additional parameters when \code{bs_type
= "ms_varma_garch"}
\itemize{
\item \code{collect_diagnostics} Logical. Enable diagnostics with
\code{collect_diagnostics = TRUE}. Diagnostics can only be extracted if
\code{return_fit = TRUE}.
\item \code{verbose} Logical. If TRUE, print detailed diagnostic information
during estimation. Default is FALSE.
\item \code{verbose_file} Character string specifying path to file for
verbose output. If NULL (default), verbose output goes to console. If
specified, all verbose output is written to this file instead. Only used if
verbose = TRUE.
}
See details in \code{vignette("Diagnostics", package = "tsbs")}.
}

}

\subsection{\code{taper_type} when \code{block_type="tapered"}}{

For block length \eqn{n}, and index \eqn{i} within the block, and \eqn{0 \leq i \leq n},
\itemize{
\item \code{"cosine"}: Hann window
\deqn{w(i) = \dfrac{1}{2} \left(1 - \cos \left( \dfrac{2 \pi i}{n - i} \right ) \right)}
\item \code{"bartlett"}: Triangular window
\deqn{w(i) = 1 - \left | \dfrac{i - (n - 1) / 2}{(n - 1) / 2} \right |,\ \ \ \alpha \in [0, 1]}
\item \code{"tukey"}: Cosine tapered window. At \eqn{\alpha = 0} it becomes
rectangular, and at \eqn{\alpha = 1} it becomes a Hann window.

We implement the Tukey (tapered cosine) window using the convention
\eqn{i = 0, \dots, n-1} for a window of length \eqn{n} and taper
parameter \eqn{\alpha \in [0,1]}, consistent with common numerical
libraries such as MATLAB and SciPy (see MATLAB tukeywin,
SciPy scipy.signal.windows.tukey). After index shift and reflection this
is algebraically equivalent to the classical definition in Harris (1978),
which instead centers the index symmetrically around zero.

Let \eqn{N = n - 1} be the last index of the block, and let the running
index be \eqn{i = 0, 1, \dots, N}.

The window weights \eqn{w[i]} are defined piecewise as follows:
\enumerate{
\item Left taper region (\eqn{0 \le i < \alpha N / 2}):
\eqn{
      w[i] = \frac{1}{2} \left[ 1 + \cos\left( \pi \left( \frac{2 i}{\alpha N} - 1 \right) \right) \right]
    }
\item Central (non-tapered) region (\eqn{\alpha N / 2 \le i \le N (1 - \alpha/2)}):
\eqn{
      w[i] = 1
    }
\item Right taper region (\eqn{N (1 - \alpha/2) < i \le N}):
\eqn{
      w[i] = \frac{1}{2} \left[ 1 + \cos\left( \pi \left( \frac{2 i}{\alpha N} - \frac{2}{\alpha} + 1 \right) \right) \right]
    }
}
}

(Harris, 1978)
}
}
\examples{
set.seed(123)
x <- arima.sim(n = 100, list(ar = 0.8))
result <- tsbs(
  x = as.matrix(x),
  block_length = 10,
  bs_type = "stationary",
  num_blocks = 5,
  num_boots = 10,
  func = mean,
  apply_func_to = "cols"
)
print(result$func_out_means)

}
\references{
Harris, F. J. (1978). "On the Use of Windows for
Harmonic Analysis with the Discrete Fourier Transform." (Proceedings of the
IEEE, 66(1), pp. 66f)
}
