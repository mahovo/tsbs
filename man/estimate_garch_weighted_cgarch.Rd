% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CGARCH_PACKAGE_DOCUMENTATION.R, R/cgarch.R
\name{estimate_garch_weighted_cgarch}
\alias{estimate_garch_weighted_cgarch}
\title{Estimate Copula GARCH Parameters with Weighted Likelihood}
\usage{
estimate_garch_weighted_cgarch(
  residuals,
  weights,
  spec,
  diagnostics = NULL,
  iteration = NULL,
  state = NULL,
  verbose = FALSE,
  dcc_threshold = 0.02,
  dcc_criterion = "bic",
  force_constant = FALSE
)
}
\arguments{
\item{residuals}{Matrix of residuals (T x k)}

\item{weights}{Vector of observation weights (length T)}

\item{spec}{Model specification list containing:
\itemize{
\item garch_spec_fun: "cgarch_modelspec"
\item garch_spec_args: list with dcc_order, dynamics, transformation, copula,
garch_model (univariate specs)
\item start_pars: starting parameter values
\item distribution: copula distribution ("mvn" or "mvt")
}}

\item{diagnostics}{Optional diagnostics collector object}

\item{iteration}{Current EM iteration number}

\item{state}{Current regime state index}

\item{verbose}{Logical; print diagnostic information}

\item{dcc_threshold}{Threshold for DCC degeneracy detection (default 0.02)}

\item{dcc_criterion}{Selection criterion for constant vs dynamic ("bic", "aic", "threshold")}

\item{force_constant}{Logical; if TRUE, skip dynamic estimation}
}
\value{
A list containing:
\describe{
\item{garch_pars}{List of k lists, each with univariate GARCH parameters}
\item{dcc_pars}{Named list with DCC/ADCC parameters (alpha_1, beta_1,
optionally gamma_1 for ADCC)}
\item{dist_pars}{Named list with distribution parameters (shape for MVT)}
\item{weighted_ll}{Scalar weighted log-likelihood}
\item{warnings}{List of any warnings generated during estimation}
}

List with:
\itemize{
\item coefficients: list with garch_pars, dcc_pars, dist_pars, correlation_type
\item warnings: list of warning messages
\item diagnostics: updated diagnostics object
}
}
\description{
Two-stage weighted maximum likelihood estimation for Copula GARCH models
within the MS-VARMA-GARCH framework. This is the main workhorse function
called during the EM algorithm's M-step for multivariate models using
copula-based dependence structures.

Implements weighted MLE for Copula GARCH models.
Stage 1: Estimate univariate GARCH parameters for each series
Stage 2: Estimate copula dependence parameters (DCC dynamics + shape)
}
\details{
\subsection{DCC (Dynamic Conditional Correlation) Models}{

DCC models capture time-varying correlations between multiple series by
modeling the correlation dynamics directly on standardized residuals. This
is the standard approach for multivariate GARCH modeling in the tsbs package.

To use DCC, set \code{garch_spec_fun = "dcc_modelspec"} in your spec.
See \code{\link[tsmarch:dcc_modelspec.generic]{tsmarch::dcc_modelspec()}} for the tsmarch specification function.

\strong{DCC-specific \code{garch_spec_args}:}
\itemize{
\item \code{dcc_order}: Integer vector c(p, q) for DCC(p, q) order. Default is
c(1, 1). Note: DCC(1,1) uses analytical gradients; higher orders use
numerical differentiation.
\item \code{dynamics}: Character. Correlation dynamics type:
\itemize{
\item \code{"constant"}: Time-invariant correlation (reduces to CCC model)
\item \code{"dcc"}: Standard DCC dynamics
\item \code{"adcc"}: Asymmetric DCC (negative shocks have larger impact)
}
\item \code{distribution}: Character. Multivariate distribution:
\itemize{
\item \code{"mvn"}: Multivariate Normal
\item \code{"mvt"}: Multivariate Student-t (adds shape parameter)
}
}

\strong{Important}: For DCC models, the univariate GARCH distributions should
always be Normal (\code{distribution = "norm"}), regardless of whether the
multivariate distribution is MVN or MVT. The multivariate distribution
applies to the joint model, not the marginals.

\strong{Example DCC specification:}

\if{html}{\out{<div class="sourceCode">}}\preformatted{spec_dcc <- list(
  list(
    var_order = 1,
    garch_spec_fun = "dcc_modelspec",
    distribution = "mvn",
    garch_spec_args = list(
      dcc_order = c(1, 1),
      dynamics = "dcc",
      distribution = "mvn",
      garch_model = list(univariate = list(
        list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
        list(model = "garch", garch_order = c(1, 1), distribution = "norm")
      ))
    ),
    start_pars = list(
      var_pars = rep(0, 6),
      garch_pars = list(
        list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85),
        list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85)
      ),
      dcc_pars = list(alpha_1 = 0.05, beta_1 = 0.90),
      dist_pars = NULL
    )
  )
)
}\if{html}{\out{</div>}}

For ADCC (asymmetric correlation dynamics), use \code{dynamics = "adcc"} and
include gamma parameters in \code{dcc_pars}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{dcc_pars = list(alpha_1 = 0.05, gamma_1 = 0.03, beta_1 = 0.90)
}\if{html}{\out{</div>}}
}

\subsection{Two-Stage Estimation}{

Stage 1 estimates univariate GARCH parameters for each series using
weighted quasi-maximum likelihood. Stage 2 estimates the copula dependence
parameters (DCC/ADCC dynamics and distribution shape) given the Stage 1
volatilities.
}

\subsection{Estimation Flow}{
\enumerate{
\item \strong{Stage 1 (Marginals)}: For each series i = 1, ..., k:
\itemize{
\item Fit univariate GARCH(p,q) with weighted likelihood
\item Extract conditional volatility σ_{i,t}
\item Compute standardized residuals z_{i,t} = ε_{i,t} / σ_{i,t}
}
\item \strong{PIT Transformation}: Transform z to uniform margins U:
\itemize{
\item Parametric: U_{i,t} = F_i(z_{i,t}; θ_i)
\item Empirical: U_{i,t} = F̂_n(z_{i,t})
\item SPD: Combines kernel density center with parametric tails
}
\item \strong{Copula Residuals}: Transform U to copula space:
\itemize{
\item MVN copula: Z_{i,t} = Φ^{-1}(U_{i,t})
\item MVT copula: Z_{i,t} = t_ν^{-1}(U_{i,t}) / √(ν/(ν-2))
}
\item \strong{Stage 2 (Dependence)}: Optimize copula parameters:
\itemize{
\item DCC(1,1): Uses analytical gradient with reparameterization
\item DCC(p,q): Uses numerical gradient
\item ADCC: Uses numerical gradient with asymmetry parameter
}
}
}

\subsection{Reparameterization for DCC(1,1)}{

For numerical stability, DCC(1,1) parameters are transformed:
\itemize{
\item ψ = logit(α + β) (persistence in logit space)
\item φ = log(α / β) (ratio in log space)
}

This maps the constrained region {α > 0, β > 0, α + β < 1} to
the unconstrained R² space.
}

The Copula GARCH model differs from DCC in how it handles the dependence
structure:
\enumerate{
\item \strong{Marginal Transformation}: Standardized residuals are transformed to
uniform \link{0,1} margins via probability integral transform (PIT). The
transformation can be:
\itemize{
\item "parametric": Uses the estimated univariate distribution's CDF
\item "empirical": Uses the empirical CDF
\item "spd": Uses semi-parametric distribution (see \code{\link{fit_spd_transform}})
}
\item \strong{Copula Specification}: The uniform margins are then transformed
according to the copula distribution:
\itemize{
\item "mvn": Multivariate Normal copula (Gaussian copula)
\item "mvt": Multivariate Student-t copula
}
\item \strong{Correlation Dynamics}: Same as DCC - can be "constant", "dcc", or "adcc"
For ADCC, see \code{\link{adcc_recursion}}.
}

This function is called by the M-step of the EM algorithm in
\code{\link{fit_ms_varma_garch}} when \code{garch_spec_fun = "cgarch_modelspec"}.
}
\seealso{
\itemize{
\item \code{\link[tsmarch:dcc_modelspec.generic]{tsmarch::dcc_modelspec()}} for creating DCC specifications
\item \code{\link[=estimate_garch_weighted_dcc]{estimate_garch_weighted_dcc()}} for the weighted estimation method
\item \code{vignette("cgarch_vs_dcc", package = "tsbs")} for model comparison
}
\subsection{Copula GARCH (CGARCH) Models}{

Copula GARCH models provide an alternative to DCC for modeling dynamic
correlations in multivariate time series. While DCC directly models
correlation dynamics, CGARCH separates marginal distributions from the
dependence structure using copulas.

To use CGARCH instead of DCC, set \code{garch_spec_fun = "cgarch_modelspec"} in
your spec. See \code{\link[tsmarch:cgarch_modelspec.generic]{tsmarch::cgarch_modelspec()}} for the tsmarch specification function.

\strong{Key differences from DCC:}
\itemize{
\item Uses Probability Integral Transform (PIT) to transform standardized
residuals to uniform margins before modeling dependence
\item Supports multiple transformation methods: "parametric", "empirical",
or "spd" (semi-parametric distribution)
\item Copula distribution can be "mvn" (Gaussian) or "mvt" (Student-t)
\item More flexible tail dependence modeling with Student-t copula
}

\strong{CGARCH-specific \code{garch_spec_args}:}
\itemize{
\item \code{transformation}: Character. Method for PIT transformation:
\itemize{
\item \code{"parametric"}: Uses fitted univariate distribution CDFs
\item \code{"empirical"}: Uses empirical CDFs (non-parametric)
\item \code{"spd"}: Semi-parametric distribution combining kernel density
in the center with parametric tails
}
\item \code{copula}: Character. Copula distribution: \code{"mvn"} or \code{"mvt"}
\item \code{dynamics}: Character. Correlation dynamics type:
\itemize{
\item \code{"constant"}: Time-invariant correlation
\item \code{"dcc"}: Dynamic Conditional Correlation
\item \code{"adcc"}: Asymmetric DCC (captures leverage effects where
negative returns have larger impact on correlation)
}
\item \code{dcc_order}: Integer vector c(p, q) for DCC/ADCC order
}

\strong{Example CGARCH specification:}

\if{html}{\out{<div class="sourceCode">}}\preformatted{spec_cgarch <- list(
  list(
    var_order = 1,
    garch_spec_fun = "cgarch_modelspec",
    distribution = "mvn",
    garch_spec_args = list(
      dcc_order = c(1, 1),
      dynamics = "dcc",
      transformation = "parametric",
      copula = "mvn",
      garch_model = list(univariate = list(
        list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
        list(model = "garch", garch_order = c(1, 1), distribution = "norm")
      ))
    ),
    start_pars = list(
      var_pars = rep(0, 6),
      garch_pars = list(
        list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85),
        list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85)
      ),
      dcc_pars = list(alpha_1 = 0.05, beta_1 = 0.90),
      dist_pars = NULL
    )
  )
)
}\if{html}{\out{</div>}}

For ADCC (asymmetric correlation dynamics), use \code{dynamics = "adcc"} and
include gamma parameters:

\if{html}{\out{<div class="sourceCode">}}\preformatted{garch_spec_args = list(
  dynamics = "adcc",
  ...
),
start_pars = list(
  ...
  dcc_pars = list(alpha_1 = 0.05, gamma_1 = 0.02, beta_1 = 0.90)
)
}\if{html}{\out{</div>}}
}

\itemize{
\item \code{\link[tsmarch:dcc_modelspec.generic]{tsmarch::dcc_modelspec()}} for creating DCC specifications
\item \code{\link[tsmarch:cgarch_modelspec.generic]{tsmarch::cgarch_modelspec()}} for creating CGARCH specifications
\item \code{\link[=estimate_garch_weighted_dcc]{estimate_garch_weighted_dcc()}} for DCC weighted estimation
\item \code{\link[=estimate_garch_weighted_cgarch]{estimate_garch_weighted_cgarch()}} for CGARCH weighted estimation
\item \code{\link[=compute_pit_transform]{compute_pit_transform()}} for PIT transformation details
\item \code{\link[=adcc_recursion]{adcc_recursion()}} for asymmetric DCC dynamics
\item \code{vignette("cgarch_vs_dcc", package = "tsbs")} for model comparison
\item \code{vignette("Diagnostics", package = "tsbs")} for diagnostic system
}

\code{\link[=estimate_copula_parameters_weighted]{estimate_copula_parameters_weighted()}} for Stage 2 estimation details
\code{\link[=compute_pit_transform]{compute_pit_transform()}} for PIT transformation
\code{\link[=copula_nll]{copula_nll()}} for copula likelihood computation

\itemize{
\item \code{\link{tsbs}}: Main bootstrap function (use \code{garch_spec_fun = "cgarch_modelspec"})
\item \code{\link{estimate_copula_parameters_weighted}}: Stage 2 estimation
\item \code{\link{compute_pit_transform}}: PIT transformation methods
\item \code{\link{copula_nll}}: Copula log-likelihood
\item \code{\link{adcc_recursion}}: ADCC dynamics
\item \code{\link{estimate_garch_weighted_dcc}}: Alternative DCC estimator
}
}
\keyword{internal}
