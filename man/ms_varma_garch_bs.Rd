% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_functions.R
\name{ms_varma_garch_bs}
\alias{ms_varma_garch_bs}
\title{Stationary Bootstrap for a General MS-VARMA-GARCH Model}
\usage{
ms_varma_garch_bs(
  x,
  n_boot = NULL,
  num_blocks = 100,
  num_boots = 100,
  M,
  d = 0,
  spec,
  model_type = c("univariate", "multivariate"),
  control = list(),
  parallel = FALSE,
  num_cores = 1L,
  collect_diagnostics = FALSE,
  verbose = FALSE,
  verbose_file = NULL
)
}
\arguments{
\item{x}{A numeric matrix or data frame where rows are observations and
columns are the time series variables.}

\item{n_boot}{An integer specifying the length of each bootstrapped series.
If NULL (the default), the length of the original series is used.}

\item{num_blocks}{An integer specifying the number of blocks to sample for
the bootstrap. Defaults to 100.}

\item{num_boots}{An integer specifying the total number of bootstrap samples
to generate. Defaults to 100.}

\item{M}{An integer specifying the number of states in the Markov chain.}

\item{d}{An integer specifying the order of differencing for the ARIMA model.}

\item{spec}{A list of model specifications, one for each of the M states.}

\item{model_type}{A character string, either "univariate" or "multivariate".}

\item{control}{A list of control parameters for the EM algorithm.}

\item{parallel}{A logical value indicating whether to use parallel processing.}

\item{num_cores}{An integer specifying the number of cores for parallel processing.}

\item{collect_diagnostics}{Logical. Collect diagnostics or not.}

\item{verbose}{Logical. If TRUE, print detailed diagnostic information during
estimation. Default is FALSE.}

\item{verbose_file}{Character string specifying path to file for verbose output.
If NULL (default), verbose output goes to console. If specified, all verbose
output is written to this file instead. Only used if verbose = TRUE.}
}
\value{
A list of bootstrapped time series matrices.
}
\description{
Fits a flexible \eqn{n}-state Markov-Switching Vector ARIMA\eqn{(p, d, q)}-
GARCH model and then uses the estimated state sequence to perform a stationary
block bootstrap. This generates resampled time series that preserve the
state-dependent properties of the original data.
}
\details{
The fitted model is defined as:

Let \eqn{y_t} be the \eqn{k \times 1} vector of observations at time \eqn{t}.
The model assumes that the data-generating process is governed by a latent
(unobserved) state variable, \eqn{S_t}, which follows a first-order Markov
chain with \eqn{M} states.

\enumerate{
\item \strong{State Process}: The evolution of the state is described by the
\eqn{M \times M} transition probability matrix \eqn{P}, where the element
\eqn{p_{ij}} is the probability of transitioning from state \eqn{i} to state \eqn{j}:
\deqn{p_{ij} = P(S_t = j | S_{t-1} = i)}
The matrix \eqn{P} is structured such that \eqn{P_{ij} = p_{ij}}, and its
rows sum to one: \eqn{\sum_{j=1}^{M} p_{ij} = 1} for all \eqn{i=1, \dots, M}.

\item \strong{Observation Process}: Conditional on the system being in state
\eqn{S_t = j}, each of the \eqn{k} time series, \eqn{y_{i,t}} for
\eqn{i=1, \dots, k}, is assumed to follow an independent
ARIMA(\eqn{p_j, d_j, q_j})-GARCH(\eqn{q'_j, p'_j}) process. The parameters
for both the mean and variance equations are specific to the state \eqn{j}.
\itemize{
\item \strong{Mean Equation (ARIMA)}:
\deqn{\phi_j(L)(1-L)^{d_j} (y_{i,t} - \mu_j) = \theta_j(L) \varepsilon_{i,t}}
where \eqn{\phi_j(L)} and \eqn{\theta_j(L)} are the AR and MA lag
polynomials, \eqn{\mu_j} is the mean, and \eqn{\varepsilon_{i,t}} is the
innovation term, all specific to state \eqn{j}.
\item \strong{Variance Equation (GARCH)}: The innovations have a conditional
variance \eqn{\sigma_{i,t}^2} that evolves according to:
\deqn{\varepsilon_{i,t} = \sigma_{i,t} z_{i,t}, \quad z_{i,t} \sim \mathcal{N}(0,1)}
\deqn{\sigma_{i,t}^2 = \omega_j + \sum_{l=1}^{q'_j} \alpha_{j,l} \varepsilon_{i,t-l}^2 + \sum_{l=1}^{p'_j} \beta_{j,l} \sigma_{i,t-l}^2}
where \eqn{\omega_j, \alpha_{j,l}, \beta_{j,l}} are the GARCH parameters for state \eqn{j}.
}
}
Let \eqn{\Psi_j = \{\mu_j, \phi_j, \theta_j, \omega_j, \alpha_j, \beta_j\}} be
the complete set of ARIMA-GARCH parameters for state \eqn{j}, and let
\eqn{\Psi = \{\Psi_1, \dots, \Psi_M, P\}} be the full parameter set for the
entire model. The EM algorithm using a Hamilton Filter & Kim Smoother for the
E-step is used to find the Maximum Likelihood Estimate (MLE) of \eqn{\Psi}.

The tsbs package uses different optimization strategies for DCC models
depending on the model order:

\strong{DCC(1,1) - Reparameterized Optimization}

For the common DCC(1,1) case, we use a reparameterization that transforms
the constrained problem into an unconstrained one:
\itemize{
\item Original: \eqn{\alpha \in (0,1), \beta \in (0,1), \alpha + \beta < 1}
\item Reparameterized: \eqn{persistence \in (0,1), ratio \in (0,1)}
}

where \eqn{persistence = \alpha + \beta} and \eqn{ratio = \alpha/(\alpha + \beta)}.

This eliminates the stationarity constraint since \eqn{\alpha + \beta = persistence < 1}
is automatically satisfied by the box constraint on persistence.

Benefits:
\itemize{
\item No penalty function discontinuities
\item More stable optimization near high-persistence regions
\item Eliminates "dcc_penalty" warnings from optimizer exploration
}

\strong{DCC(p,q) with max(p,q) > 1 - Penalty Method}

For higher-order DCC models, reparameterization becomes significantly more
complex (requiring softmax distributions over parameter vectors). We therefore
use the standard penalty method:
\itemize{
\item Box constraints: \eqn{\alpha_j, \beta_j \in (\epsilon, 1-\epsilon)}
\item Stationarity enforced via penalty when \eqn{\sum \alpha + \sum \beta \geq 1}
}

This may result in optimizer instability warnings for models with high
persistence.
}
\references{
Natatou Moutari, D. et al. (2021). Dependence Modeling and Risk Assessment
of a Financial Portfolio with ARMA-APARCH-EVT models based on HACs.
\href{http://arxiv.org/abs/2105.09473}{arXiv:2105.09473}
}
