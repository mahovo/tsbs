% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrap_functions.R
\name{hmm_bootstrap_old}
\alias{hmm_bootstrap_old}
\title{Hidden Markov Model (HMM) Bootstrap for Multivariate Time Series}
\usage{
hmm_bootstrap_old(
  x,
  n_boot = NULL,
  num_states = 2,
  num_blocks = 100,
  num_boots = 100,
  parallel = FALSE,
  num_cores = 1L
)
}
\arguments{
\item{x}{Numeric vector representing the time series.}

\item{n_boot}{Length of bootstrap series.}

\item{num_states}{Integer number of hidden states for the HMM.}

\item{num_blocks}{Integer number of blocks to sample for each bootstrap replicate.}

\item{num_boots}{Integer number of bootstrap replicates to generate.}

\item{parallel}{Parallelize computation? \code{TRUE} or \code{FALSE}.}

\item{num_cores}{Number of cores.}
}
\value{
A list of numeric vectors, each one a bootstrap replicate.
}
\description{
Fits a Gaussian Hidden Markov Model (HMM) to a multivariate time series
and generates bootstrap replicates by resampling regime-specific blocks.
}
\details{
This function:
\itemize{
\item Fits a Gaussian HMM to \code{x} using \code{depmixS4::depmix()} and
\code{depmixS4::fit()}.
\item Uses Viterbi decoding (\code{posterior(fit, type = "viterbi")$state})
to assign each observation to a state.
\item Samples contiguous blocks of observations belonging to each state.
}

If \code{n_boot} is set, the last block will be truncated when necessary to match
the length (\code{n_boot}) of the bootstrap series. This is the only way to ensure
equal length of all bootstrap series, as the length of each block is random.
If \code{n_boot} is not set, \code{num_blocks} must be set, and the length of each
bootstrap series will be determined by the number of blocks and the random
lengths of the individual blocks for that particular series. This almost
certainly results in bootstrap series of different lengths.

For multivariate series (matrices or data frames), the function fits a single
HMM where all variables are assumed to depend on the same underlying hidden
state sequence. The returned bootstrap samples are matrices with the same
number of columns as the input \code{x}.

Hidden Markov Model definition:
\itemize{
\item \eqn{T}: sequence length
\item \eqn{K}: number of hidden states
\item \eqn{\mathbf{X} = (X_1, \dots, X_T)}: observed sequence
\item \eqn{\mathbf{S} = (S_1, \dots, S_T)}: hidden (latent) state sequence
\item \eqn{\pi_i = \mathbb{P}(S_1 = i)}: initial state distribution
\item \eqn{A = [a_{ij}], \text{ where } a_{ij} = \mathbb{P}(S_{t+1} = j \mid S_t = i)}: transition matrix
\item \eqn{b_j(x_t) = \mathbb{P}(X_t = x_t \mid S_t = j)}: output probability
}

Joint probability of the observations and the hidden states:

\eqn{\mathbb{P}(\mathbf{X}, \mathbf{S}) = \pi_{S_1} b_{S_1}(X_1) \prod_{t=2}^{T} a_{S_{t-1} S_t} b_{S_t}(X_t)}

Marginal probability of the observed data is obtained by summing over all
possible hidden state sequences:

\eqn{\mathbb{P}(\mathbf{X}) = \sum_{\mathbf{S}} \mathbb{P}(\mathbf{X}, \mathbf{S})}

(Beware of the "double use of data" problem: The bootstrap procedure relies
on regime classification, but the regimes themselves are estimated from the
same data and depend on the parameters being resampled.)
}
\examples{
if (requireNamespace("depmixS4", quietly = TRUE)) {

  # --- Example 1: Univariate Time Series (Vector) ---

  # 1.1. Simulate data with two states (one low-variance, one high-variance)
  set.seed(123)
  n_per_state <- 80
  state1_data <- rnorm(n_per_state, mean = 0, sd = 1)
  state2_data <- rnorm(n_per_state, mean = 2, sd = 3)
  x_univariate <- c(state1_data, state2_data, state1_data) # Total length 240

  # 1.2. Generate 5 bootstrap replicates, each of length 240
  # We use a small num_boots for a fast example.
  # Set num_blocks = NULL to avoid warning when n_boot is set.
  boots_univariate <- hmm_bootstrap(
    x_univariate,
    n_boot = 240,
    num_states = 2,
    num_blocks = NULL,
    num_boots = 5,
    parallel = FALSE
  )

  # 1.3. Check the results
  cat("--- Univariate Results ---\n")
  cat("Class of result:", class(boots_univariate), "\n")
  cat("Number of replicates:", length(boots_univariate), "\n")
  cat("Length of first replicate:", length(boots_univariate[[1]]), "\n")

  # 1.4. Plot the original series and one bootstrap replicate
  oldpar <- par(mfrow = c(2, 1), mar = c(4, 4, 2, 1))
  plot(x_univariate, type = "l", main = "Original Univariate Series", ylab = "Value")
  plot(boots_univariate[[1]], type = "l", main = "First Bootstrap Replicate", ylab = "Value")
  par(oldpar) # Reset plotting parameters


  # --- Example 2: Multivariate Time Series (Matrix) ---

  # 2.1. Simulate 2-variable data (requires MASS package)
  if (requireNamespace("MASS", quietly = TRUE)) {
    set.seed(456)
    mu1 <- c(0, 5)
    Sigma1 <- matrix(c(1, 0.7, 0.7, 1), 2, 2) # Positively correlated
    mu2 <- c(3, -2)
    Sigma2 <- matrix(c(0.5, -0.3, -0.3, 0.5), 2, 2) # Negatively correlated

    state_m1 <- MASS::mvrnorm(n_per_state, mu1, Sigma1)
    state_m2 <- MASS::mvrnorm(n_per_state, mu2, Sigma2)
    x_multivariate <- rbind(state_m1, state_m2, state_m1) # 240x2 matrix

    # 2.2. Generate 3 bootstrap replicates
    # NOTE: The hmm_bootstrap function as provided in the prompt may
    # fail here. It passes a single `family = gaussian()` to depmixS4,
    # which often causes errors for multivariate data.
    # We wrap this in try() to allow the example to run without error.
    boots_multi <- try(hmm_bootstrap(
      x_multivariate,
      n_boot = 240,
      num_states = 2,
      num_blocks = NULL, # Set to NULL to avoid warning
      num_boots = 3
    ))

    # 2.3. Check the results if the call succeeded
    if (!inherits(boots_multi, "try-error")) {
      cat("\n--- Multivariate Results ---\n")
      cat("Class of result:", class(boots_multi), "\n")
      cat("Number of replicates:", length(boots_multi), "\n")
      cat("Dimensions of first replicate:", dim(boots_multi[[1]]), "\n")

      # 2.4. Plot the first variable of original vs. bootstrap
      oldpar <- par(mfrow = c(2, 1), mar = c(4, 4, 2, 1))
      plot(x_multivariate[, 1], type = "l", main = "Original Series (Variable 1)", ylab = "Value")
      plot(boots_multi[[1]][, 1], type = "l", main = "Bootstrap Replicate (Variable 1)", ylab = "Value")
      par(oldpar)

    } else {
      cat("\n--- Multivariate Example Failed ---\n")
      cat("This is likely due to the hmm_bootstrap function's handling\n")
      cat("of multivariate data in depmixS4. See example comments.\n")
      print(boots_multi)
    }

  } else {
    cat("MASS package not available, skipping multivariate example.\n")
  }

} else {
  cat("depmixS4 package not available, skipping all examples.\n")
}
  
}
\references{
Holst, U., Lindgren, G., Holst, J. and Thuvesholmen, M. (1994), Recursive
Estimation In Switching Autoregressions With A Markov Regime. Journal of
Time Series Analysis, 15: 489-506.
\url{https://doi.org/10.1111/j.1467-9892.1994.tb00206.x}
}
