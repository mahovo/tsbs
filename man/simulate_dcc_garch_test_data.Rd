% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/diagnostic_utils.R
\name{simulate_dcc_garch_test_data}
\alias{simulate_dcc_garch_test_data}
\title{#' Simulate DCC-GARCH Data
#'
#' Simulate realistic multivariate time series data from a DCC-GARCH process.
#' This function is primarily intended for testing and examples.
#'
#' @param n Integer number of observations to simulate
#' @param k Integer number of series (default: 2)
#' @param omega Numeric vector of length k: GARCH intercepts (default: c(0.05, 0.08))
#' @param alpha_garch Numeric vector of length k: ARCH effects (default: c(0.10, 0.12))
#' @param beta_garch Numeric vector of length k: GARCH effects (default: c(0.85, 0.82))
#' @param alpha_dcc Numeric: DCC alpha parameter (default: 0.04)
#' @param beta_dcc Numeric: DCC beta parameter (default: 0.93)
#' @param Qbar Matrix (k x k): Unconditional correlation matrix. If NULL, uses
#'   moderate correlation (0.5 off-diagonal)
#' @param seed Integer random seed for reproducibility
#'
#' @return A matrix of dimension (n x k) with simulated returns
#'
#' @details
#' The function simulates data from the DCC-GARCH model:
#' \deqn{y_{i,t} = \sqrt{h_{i,t}} z_{i,t}}
#' \deqn{h_{i,t} = \omega_i + \alpha_i y_{i,t-1}^2 + \beta_i h_{i,t-1}}
#' \deqn{Q_t = \bar{Q}(1-\alpha-\beta) + \alpha z_{t-1}z_{t-1}' + \beta Q_{t-1}}
#' \deqn{R_t = \text{diag}(Q_t)^{-1/2} Q_t \text{diag}(Q_t)^{-1/2}}
#'
#' where \eqn{z_t \sim N(0, R_t)}.
#'
#' @examples
#' \dontrun{
#' # Simulate 500 observations with default parameters
#' y <- simulate_dcc_garch(n = 500, seed = 42)
#' 
#' # Custom parameters with higher volatility
#' y_high_vol <- simulate_dcc_garch(
#'   n = 300,
#'   omega = c(0.15, 0.20),
#'   alpha_garch = c(0.15, 0.18),
#'   beta_garch = c(0.70, 0.65),
#'   seed = 123
#' )
#' 
#' # Constant correlation (set alpha_dcc = 0)
#' y_const <- simulate_dcc_garch(n = 200, alpha_dcc = 0, beta_dcc = 0, seed = 456)
#' }
#'
#' @export
simulate_dcc_garch <- function(n,
k = 2,
omega = c(0.05, 0.08),
alpha_garch = c(0.10, 0.12),
beta_garch = c(0.85, 0.82),
alpha_dcc = 0.04,
beta_dcc = 0.93,
Qbar = NULL,
seed = NULL) {Input validation

if (n <= 0 || n != round(n)) {
stop("n must be a positive integer")
}
if (k <= 0 || k != round(k)) {
stop("k must be a positive integer")
}
if (length(omega) != k || length(alpha_garch) != k || length(beta_garch) != k) {
stop("omega, alpha_garch, and beta_garch must have length k")
}
if (any(omega <= 0)) {
stop("All omega values must be positive")
}
if (any(alpha_garch < 0) || any(beta_garch < 0)) {
stop("alpha_garch and beta_garch must be non-negative")
}
if (any((alpha_garch + beta_garch) >= 1)) {
stop("GARCH process must be stationary: alpha + beta < 1")
}
if (alpha_dcc < 0 || beta_dcc < 0) {
stop("alpha_dcc and beta_dcc must be non-negative")
}
if ((alpha_dcc + beta_dcc) >= 1 && (alpha_dcc > 0 || beta_dcc > 0)) {
stop("DCC process must be stationary: alpha_dcc + beta_dcc < 1")
}Set seed if provided

if (!is.null(seed)) {
set.seed(seed)
}Default Qbar (unconditional correlation)

if (is.null(Qbar)) {
Qbar <- matrix(0.5, k, k)
diag(Qbar) <- 1
}Validate Qbar

if (!is.matrix(Qbar) || nrow(Qbar) != k || ncol(Qbar) != k) {
stop("Qbar must be a k x k matrix")
}
if (!all(diag(Qbar) == 1)) {
stop("Qbar must have 1s on the diagonal")
}
eig_vals <- eigen(Qbar, symmetric = TRUE, only.values = TRUE)$values
if (any(eig_vals < 0)) {
stop("Qbar must be positive definite")
}Initialize

y_sim <- matrix(0, n, k)
h <- matrix(0, n, k)
Q <- Qbar
R <- QbarInitialize conditional variances

for (i in 1:k) {
h\link{1, i} <- omega\link{i} / (1 - alpha_garch\link{i} - beta_garch\link{i})
}Simulate

for (t in 1:n) {
# Draw correlated innovations
z <- as.vector(mvtnorm::rmvnorm(1, sigma = R))

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Generate returns
for (i in 1:k) \{
  y_sim[t, i] <- sqrt(h[t, i]) * z[i]
  
  # Update variance for next period
  if (t < n) \{
    h[t+1, i] <- omega[i] + alpha_garch[i] * y_sim[t, i]^2 + 
      beta_garch[i] * h[t, i]
  \}
\}

# Update DCC dynamics for next period
if (t < n && (alpha_dcc > 0 || beta_dcc > 0)) \{
  z_mat <- matrix(z, ncol = 1)
  Q <- Qbar * (1 - alpha_dcc - beta_dcc) + 
    alpha_dcc * (z_mat \%*\% t(z_mat)) + 
    beta_dcc * Q
  
  # Standardize to correlation
  Q_diag_inv_sqrt <- diag(1/sqrt(diag(Q)))
  R <- Q_diag_inv_sqrt \%*\% Q \%*\% Q_diag_inv_sqrt
\}
}\if{html}{\out{</div>}}

}

colnames(y_sim) <- paste0("series_", 1:k)

return(y_sim)
}
Simulate DCC-GARCH data for testing}
\usage{
simulate_dcc_garch_test_data(
  n = 200,
  k = 2,
  alpha = 0.05,
  beta = 0.9,
  seed = 123
)
}
\arguments{
\item{n}{Number of observations}

\item{k}{Number of series}

\item{alpha}{DCC alpha parameter}

\item{beta}{DCC beta parameter}

\item{seed}{Random seed}
}
\value{
List with y (data), true_params, Qbar
}
\description{
#' Simulate DCC-GARCH Data
#'
#' Simulate realistic multivariate time series data from a DCC-GARCH process.
#' This function is primarily intended for testing and examples.
#'
#' @param n Integer number of observations to simulate
#' @param k Integer number of series (default: 2)
#' @param omega Numeric vector of length k: GARCH intercepts (default: c(0.05, 0.08))
#' @param alpha_garch Numeric vector of length k: ARCH effects (default: c(0.10, 0.12))
#' @param beta_garch Numeric vector of length k: GARCH effects (default: c(0.85, 0.82))
#' @param alpha_dcc Numeric: DCC alpha parameter (default: 0.04)
#' @param beta_dcc Numeric: DCC beta parameter (default: 0.93)
#' @param Qbar Matrix (k x k): Unconditional correlation matrix. If NULL, uses
#'   moderate correlation (0.5 off-diagonal)
#' @param seed Integer random seed for reproducibility
#'
#' @return A matrix of dimension (n x k) with simulated returns
#'
#' @details
#' The function simulates data from the DCC-GARCH model:
#' \deqn{y_{i,t} = \sqrt{h_{i,t}} z_{i,t}}
#' \deqn{h_{i,t} = \omega_i + \alpha_i y_{i,t-1}^2 + \beta_i h_{i,t-1}}
#' \deqn{Q_t = \bar{Q}(1-\alpha-\beta) + \alpha z_{t-1}z_{t-1}' + \beta Q_{t-1}}
#' \deqn{R_t = \text{diag}(Q_t)^{-1/2} Q_t \text{diag}(Q_t)^{-1/2}}
#'
#' where \eqn{z_t \sim N(0, R_t)}.
#'
#' @examples
#' \dontrun{
#' # Simulate 500 observations with default parameters
#' y <- simulate_dcc_garch(n = 500, seed = 42)
#' 
#' # Custom parameters with higher volatility
#' y_high_vol <- simulate_dcc_garch(
#'   n = 300,
#'   omega = c(0.15, 0.20),
#'   alpha_garch = c(0.15, 0.18),
#'   beta_garch = c(0.70, 0.65),
#'   seed = 123
#' )
#' 
#' # Constant correlation (set alpha_dcc = 0)
#' y_const <- simulate_dcc_garch(n = 200, alpha_dcc = 0, beta_dcc = 0, seed = 456)
#' }
#'
#' @export
simulate_dcc_garch <- function(n,
k = 2,
omega = c(0.05, 0.08),
alpha_garch = c(0.10, 0.12),
beta_garch = c(0.85, 0.82),
alpha_dcc = 0.04,
beta_dcc = 0.93,
Qbar = NULL,
seed = NULL) {Input validation

if (n <= 0 || n != round(n)) {
stop("n must be a positive integer")
}
if (k <= 0 || k != round(k)) {
stop("k must be a positive integer")
}
if (length(omega) != k || length(alpha_garch) != k || length(beta_garch) != k) {
stop("omega, alpha_garch, and beta_garch must have length k")
}
if (any(omega <= 0)) {
stop("All omega values must be positive")
}
if (any(alpha_garch < 0) || any(beta_garch < 0)) {
stop("alpha_garch and beta_garch must be non-negative")
}
if (any((alpha_garch + beta_garch) >= 1)) {
stop("GARCH process must be stationary: alpha + beta < 1")
}
if (alpha_dcc < 0 || beta_dcc < 0) {
stop("alpha_dcc and beta_dcc must be non-negative")
}
if ((alpha_dcc + beta_dcc) >= 1 && (alpha_dcc > 0 || beta_dcc > 0)) {
stop("DCC process must be stationary: alpha_dcc + beta_dcc < 1")
}Set seed if provided

if (!is.null(seed)) {
set.seed(seed)
}Default Qbar (unconditional correlation)

if (is.null(Qbar)) {
Qbar <- matrix(0.5, k, k)
diag(Qbar) <- 1
}Validate Qbar

if (!is.matrix(Qbar) || nrow(Qbar) != k || ncol(Qbar) != k) {
stop("Qbar must be a k x k matrix")
}
if (!all(diag(Qbar) == 1)) {
stop("Qbar must have 1s on the diagonal")
}
eig_vals <- eigen(Qbar, symmetric = TRUE, only.values = TRUE)$values
if (any(eig_vals < 0)) {
stop("Qbar must be positive definite")
}Initialize

y_sim <- matrix(0, n, k)
h <- matrix(0, n, k)
Q <- Qbar
R <- QbarInitialize conditional variances

for (i in 1:k) {
h\link{1, i} <- omega\link{i} / (1 - alpha_garch\link{i} - beta_garch\link{i})
}Simulate

for (t in 1:n) {
# Draw correlated innovations
z <- as.vector(mvtnorm::rmvnorm(1, sigma = R))

\if{html}{\out{<div class="sourceCode">}}\preformatted{# Generate returns
for (i in 1:k) \{
  y_sim[t, i] <- sqrt(h[t, i]) * z[i]
  
  # Update variance for next period
  if (t < n) \{
    h[t+1, i] <- omega[i] + alpha_garch[i] * y_sim[t, i]^2 + 
      beta_garch[i] * h[t, i]
  \}
\}

# Update DCC dynamics for next period
if (t < n && (alpha_dcc > 0 || beta_dcc > 0)) \{
  z_mat <- matrix(z, ncol = 1)
  Q <- Qbar * (1 - alpha_dcc - beta_dcc) + 
    alpha_dcc * (z_mat \%*\% t(z_mat)) + 
    beta_dcc * Q
  
  # Standardize to correlation
  Q_diag_inv_sqrt <- diag(1/sqrt(diag(Q)))
  R <- Q_diag_inv_sqrt \%*\% Q \%*\% Q_diag_inv_sqrt
\}
}\if{html}{\out{</div>}}

}

colnames(y_sim) <- paste0("series_", 1:k)

return(y_sim)
}
Simulate DCC-GARCH data for testing
}
