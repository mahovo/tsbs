---
title: "test_tsbs"
output: html_document
date: "2025-08-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Univariate test

```{r}
# ===================================================================
# Full Integration Test for tsbs() with bs_type = "ms_varma_garch"
# ===================================================================

# --- 1. Load Libraries and Source All Necessary Files ---

# Ensure you have these packages installed:
# install.packages(c("Rcpp", "tsgarch", "tsmarch", "xts", "data.table", "mvtnorm"))
library(Rcpp)
library(tsgarch)
library(tsmarch)
library(xts)
library(data.table)
library(mvtnorm)

# This script assumes all required functions are loaded.
# In your package development workflow, this would be handled by devtools::load_all()
# or by sourcing the files directly.

# Source the C++ file containing the EM orchestrator.
Rcpp::sourceCpp("~/R work/tsbs/src/ms_varma_garch_fitter.cpp")

# Source the R helper functions.
source("~/R work/tsbs/R/ms-varma-garch_helper_functions.R")

# Source the main bootstrap functions, including the new ms_varma_garch_bs
# and the top-level tsbs() function.
# (Assuming they are in a file like the one below)
# source("~/R work/tsbs/R/bootstrap_functions.R")


# --- 2. Simulate Data for Testing ---
set.seed(123)
T_obs <- 1000 # Using a slightly smaller sample for a quicker test run
P_true <- matrix(c(0.98, 0.02, 0.03, 0.97), nrow = 2, byrow = TRUE)

states <- numeric(T_obs)
states[1] <- 1
for (t in 2:T_obs) {
  states[t] <- sample(1:2, size = 1, prob = P_true[states[t-1], ])
}

dummy_y <- xts::xts(rep(0, 10), order.by = Sys.Date() - (10:1))
spec1_true <- tsgarch::garch_modelspec(y = dummy_y, fixed_pars = list(mu = 0, ar1 = 0.5, omega = 0.1, alpha1 = 0.1, beta1 = 0.8))
spec2_true <- tsgarch::garch_modelspec(y = dummy_y, fixed_pars = list(mu = 0, ar1 = -0.2, omega = 0.5, alpha1 = 0.3, beta1 = 0.6))

y <- numeric(T_obs)
sim1 <- simulate(spec1_true, n.sim = T_obs)
sim2 <- simulate(spec2_true, n.sim = T_obs)

y[states == 1] <- sim1$series[states == 1]
y[states == 2] <- sim2$series[states == 2]


# --- 3. Define Model Specification for Fitting ---
# This spec is passed through tsbs() to the underlying ms_varma_garch_bs() function.
spec_to_fit <- list()

# State 1 spec
spec_to_fit[[1]] <- list(
  arma_order = c(1, 0),
  garch_model = "garch",
  garch_order = c(1, 1),
  distribution = "norm",
  start_pars = list(
    arma_pars = list(ar1 = 0.1),
    garch_pars = list(omega = 0.1, alpha1 = 0.05, beta1 = 0.9)
  )
)

# State 2 spec
spec_to_fit[[2]] <- list(
  arma_order = c(1, 0),
  garch_model = "garch",
  garch_order = c(1, 1),
  distribution = "norm",
  start_pars = list(
    arma_pars = list(ar1 = 0.1),
    garch_pars = list(omega = 0.1, alpha1 = 0.05, beta1 = 0.9)
  )
)


# --- 4. Run the Top-Level tsbs() Function ---
message("Starting the full tsbs() bootstrap with bs_type = 'ms_varma_garch'...")

# Define control parameters for the fitter
control_params <- list(max_iter = 50, tol = 1e-5)

# Call the user-facing function
bootstrap_results <- tsbs(
  x = as.matrix(y),
  n_boot = T_obs, # Bootstrap series of the same length
  num_boots = 5,   # A small number of bootstrap replicates for a quick test
  bs_type = "ms_varma_garch",
  
  # --- MS-VARMA-GARCH specific arguments ---
  num_states = 2,
  d = 0,
  spec = spec_to_fit,
  model_type = "univariate",
  control = control_params,
  # --- End specific arguments ---
  
  func = function(x) c(mean = mean(x), sd = sd(x)), # Example summary function
  apply_func_to = "cols",
  parallel = TRUE,
  num_cores = 2L,
)

message("tsbs() execution complete.")


# --- 5. Print Results ---
print("--- tsbs() with MS-VARMA-GARCH Results ---")

print("Structure of the returned object:")
str(bootstrap_results, max.level = 2)

print("\nMean of summary statistics across all bootstrap replicates:")
print(bootstrap_results$func_out_means)

print("\nSummary statistics for the first bootstrap replicate:")
print(bootstrap_results$func_outs[[1]])

```

## Test with stationary bootstrap
```{r}
# Call the user-facing function
bootstrap_results <- tsbs(
  x = rnorm(50),
  n_boot = 50, # Bootstrap series of the same length
  num_boots = 5,   # A small number of bootstrap replicates for a quick test
  bs_type = "stationary",
  func = function(x) c(mean = mean(x), sd = sd(x)), # Example summary function
  apply_func_to = "cols",
  parallel = TRUE,
  num_cores = 2L,
  stationary_max_percentile = 0.9,
  stationary_max_fraction_of_n = 0.1
)

message("tsbs() execution complete.")


# --- 5. Print Results ---
print("--- tsbs() with MS-VARMA-GARCH Results ---")

print("Structure of the returned object:")
str(bootstrap_results, max.level = 2)

print("\nMean of summary statistics across all bootstrap replicates:")
print(bootstrap_results$func_out_means)

print("\nSummary statistics for the first bootstrap replicate:")
print(bootstrap_results$func_outs[[1]])
```


## Multivariate test

```{r}
# ===================================================================
# Full Integration Test for tsbs() with bs_type = "ms_varma_garch"
# MULTIVARIATE CASE
# ===================================================================

# --- 1. Load Libraries and Source All Necessary Files ---

# This script assumes all required functions are loaded.
# In your package development workflow, this would be handled by devtools::load_all()
# or by sourcing the files directly.

# Source the C++ file containing the EM orchestrator.
Rcpp::sourceCpp("~/R work/tsbs/src/ms_varma_garch_fitter.cpp")

# Source the R helper functions.
source("~/R work/tsbs/R/ms-varma-garch_helper_functions.R")

# Source the main bootstrap functions.
# (This assumes tsbs, ms_varma_garch_bs, fit_ms_varma_garch etc. are in this file)
# source("~/R work/tsbs/R/bootstrap_functions.R")


# --- 2. Simulate Multivariate Data ---
set.seed(456)
T_obs <- 1500
k_vars <- 2 # Number of variables

# True transition matrix
P_true <- matrix(c(0.98, 0.02, 0.03, 0.97), nrow = 2, byrow = TRUE)

# Simulate the state sequence
states <- numeric(T_obs)
states[1] <- 1
for (t in 2:T_obs) {
  states[t] <- sample(1:2, size = 1, prob = P_true[states[t-1], ])
}

# --- Define State-Specific Models for Simulation ---
dummy_mv_y_long <- xts::xts(matrix(rnorm(T_obs * k_vars), ncol = k_vars), order.by = Sys.Date()-(T_obs:1))

# State 1: Low volatility
garch_spec1a <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,1], garch_order = c(1,1), fixed_pars = list(omega=0.1, alpha1=0.1, beta1=0.8))
garch_spec1b <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,2], garch_order = c(1,1), fixed_pars = list(omega=0.1, alpha1=0.1, beta1=0.8))
garch_model1 <- to_multi_estimate(list(estimate(garch_spec1a, keep_tmb = TRUE), estimate(garch_spec1b, keep_tmb = TRUE)))
dcc_fit1_true <- tsmarch::dcc_modelspec(object = garch_model1, dcc_order = c(1,1), distribution = "mvt", fixed_pars = list(dcc_alpha = 0.05, dcc_beta = 0.9)) |>
  estimate()

# State 2: High volatility
garch_spec2a <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,1], garch_order = c(1,1), fixed_pars = list(omega=0.3, alpha1=0.2, beta1=0.6))
garch_spec2b <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,2], garch_order = c(1,1), fixed_pars = list(omega=0.3, alpha1=0.2, beta1=0.6))
garch_model2 <- to_multi_estimate(list(estimate(garch_spec2a, keep_tmb = TRUE), estimate(garch_spec2b, keep_tmb = TRUE)))
dcc_fit2_true <- tsmarch::dcc_modelspec(object = garch_model2, dcc_order = c(1,1), distribution = "mvt", fixed_pars = list(dcc_alpha = 0.2, dcc_beta = 0.75)) |>
  estimate()

# VAR(1) parameters
beta1_true <- matrix(c(0.01, 0.4, 0.1, 0.01, 0.1, 0.5), nrow = 3, byrow = FALSE)
beta2_true <- matrix(c(0.00, 0.1, -0.2, 0.00, -0.1, 0.2), nrow = 3, byrow = FALSE)


# --- Simulate the time series manually ---
y <- matrix(0, nrow = T_obs, ncol = k_vars)

n_state1 <- sum(states == 1)
n_state2 <- sum(states == 2)

sim1 <- simulate(dcc_fit1_true, nsim = 1, h = n_state1)
sim2 <- simulate(dcc_fit2_true, nsim = 1, h = n_state2)

innovations <- matrix(0, nrow = T_obs, ncol = k_vars)
sim1_series_mat <- t(rbind(as.matrix(sim1$garch_sim[[1]]$series), as.matrix(sim1$garch_sim[[2]]$series)))
sim2_series_mat <- t(rbind(as.matrix(sim2$garch_sim[[1]]$series), as.matrix(sim2$garch_sim[[2]]$series)))

innovations[states == 1, ] <- sim1_series_mat
innovations[states == 2, ] <- sim2_series_mat

for (t in 2:T_obs) {
  x_lagged <- c(1, y[t-1, 1], y[t-1, 2])
  if (states[t] == 1) {
    y[t, ] <- t(beta1_true) %*% x_lagged + innovations[t, ]
  } else {
    y[t, ] <- t(beta2_true) %*% x_lagged + innovations[t, ]
  }
}
colnames(y) <- c("y1", "y2")

# --- 3. Define Model Specification for Fitting ---
spec_to_fit <- list()
dummy_mv_y_short <- xts::xts(matrix(rnorm(100 * k_vars), ncol = k_vars), order.by = Sys.Date()-(100:1))
univariate_spec_template <- list(model = "garch", garch_order = c(1,1))

# State 1 spec
spec_to_fit[[1]] <- list(
  var_order = 1,
  garch_spec_fun = "dcc_modelspec",
  garch_spec_args = list(
      garch_model = list(univariate = list(univariate_spec_template, univariate_spec_template)), 
      dcc_order = c(1,1),
      distribution = "mvt"
  ),
  start_pars = list(
    var_pars = as.vector(beta1_true * 0.8),
    garch_pars = list(dcc_alpha = 0.05, dcc_beta = 0.90)
  )
)

# State 2 spec
spec_to_fit[[2]] <- list(
  var_order = 1,
  garch_spec_fun = "dcc_modelspec",
  garch_spec_args = list(
      garch_model = list(univariate = list(univariate_spec_template, univariate_spec_template)),
      dcc_order = c(1,1),
      distribution = "mvt"
  ),
  start_pars = list(
    var_pars = as.vector(beta2_true * 0.8),
    garch_pars = list(dcc_alpha = 0.1, dcc_beta = 0.8)
  )
)


# --- 4. Run the Top-Level tsbs() Function ---
message("Starting the full MULTIVARIATE tsbs() bootstrap with bs_type = 'ms_varma_garch'...")

control_params <- list(max_iter = 50, tol = 1e-5)

bootstrap_results <- tsbs(
  x = y,
  n_boot = T_obs,
  num_boots = 5,
  bs_type = "ms_varma_garch",
  
  # --- MS-VARMA-GARCH specific arguments ---
  num_states = 2,
  d = 0,
  spec = spec_to_fit,
  model_type = "multivariate",
  control = control_params,
  # --- End specific arguments ---
  
  # --- Parallelization arguments ---
  parallel = TRUE,
  num_cores = 2L,
  # --- End parallelization ---
  
  func = function(x) c(mean_y1 = mean(x[,1]), sd_y2 = sd(x[,2])), # Example summary function
  apply_func_to = "df"
)

message("tsbs() execution complete.")


# --- 5. Print Results ---
print("--- tsbs() with MULTIVARIATE MS-VARMA-GARCH Results ---")

print("Structure of the returned object:")
str(bootstrap_results, max.level = 2)

print("\nMean of summary statistics across all bootstrap replicates:")
print(bootstrap_results$func_out_means)

print("\nSummary statistics for the first bootstrap replicate:")
print(bootstrap_results$func_outs[[1]])
```

