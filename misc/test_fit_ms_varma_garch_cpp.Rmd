---
title: "Test fit_ms_varma_garch_cpp"
output: html_document
date: "2025-08-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# ===================================================================
# Multivariate Testing Script for the MS-VARMA-GARCH Fitting Procedure
# ===================================================================

# --- 1. Load Libraries and Source Code ---
# Ensure you have the R helper functions from the other Canvas loaded
# in your global environment before running this.

# install.packages(c("mvtnorm", "xts", "tsgarch", "tsmarch"))
library(mvtnorm)
library(xts)
library(tsgarch)
library(tsmarch)

# Source the C++ file containing the EM orchestrator.
# Make sure the path is correct.
Rcpp::sourceCpp("~/R work/tsbs/src/ms_varma_garch_fitter.cpp")

# --- 2. R Helper Functions ---
# The R helper functions must be in the global environment so the C++
# code can call them.
source("~/R work/tsbs/R/ms-varma-garch_helper_functions.R")
```

```{r}
# --- 2. Simulate Multivariate Data ---
set.seed(456)
T_obs <- 1500
k_vars <- 2 # Number of variables

# True transition matrix
P_true <- matrix(c(0.98, 0.02, 0.03, 0.97), nrow = 2, byrow = TRUE)

# Simulate the state sequence
states <- numeric(T_obs)
states[1] <- 1
for (t in 2:T_obs) {
  states[t] <- sample(1:2, size = 1, prob = P_true[states[t-1], ])
}

# --- Define State-Specific Models ---
dummy_mv_y_long <- xts::xts(matrix(rnorm(T_obs * k_vars), ncol = k_vars), order.by = Sys.Date()-(T_obs:1))

# Stage 1: Define and estimate the univariate GARCH models
# State 1: Low volatility
garch_spec1a <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,1], garch_order = c(1,1), fixed_pars = list(omega=0.1, alpha1=0.1, beta1=0.8))
garch_spec1b <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,2], garch_order = c(1,1), fixed_pars = list(omega=0.1, alpha1=0.1, beta1=0.8))
garch_model1 <- to_multi_estimate(list(estimate(garch_spec1a, keep_tmb = TRUE), estimate(garch_spec1b, keep_tmb = TRUE)))

# Stage 2: Pass the estimated models to the DCC spec and then estimate it
dcc_fit1_true <- tsmarch::dcc_modelspec(object = garch_model1, dcc_order = c(1,1), distribution = "mvt", fixed_pars = list(dcc_alpha = 0.05, dcc_beta = 0.9)) |>
  estimate()

# State 2: High volatility
garch_spec2a <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,1], garch_order = c(1,1), fixed_pars = list(omega=0.3, alpha1=0.2, beta1=0.6))
garch_spec2b <- tsgarch::garch_modelspec(y = dummy_mv_y_long[,2], garch_order = c(1,1), fixed_pars = list(omega=0.3, alpha1=0.2, beta1=0.6))
garch_model2 <- to_multi_estimate(list(estimate(garch_spec2a, keep_tmb = TRUE), estimate(garch_spec2b, keep_tmb = TRUE)))
dcc_fit2_true <- tsmarch::dcc_modelspec(object = garch_model2, dcc_order = c(1,1), distribution = "mvt", fixed_pars = list(dcc_alpha = 0.2, dcc_beta = 0.75)) |>
  estimate()

# VAR(1) parameters
beta1_true <- matrix(c(0.01, 0.4, 0.1, 0.01, 0.1, 0.5), nrow = 3, byrow = FALSE)
beta2_true <- matrix(c(0.00, 0.1, -0.2, 0.00, -0.1, 0.2), nrow = 3, byrow = FALSE)


# --- Simulate the time series manually ---
y <- matrix(0, nrow = T_obs, ncol = k_vars)

n_state1 <- sum(states == 1)
n_state2 <- sum(states == 2)

# --- FIX: Use nsim=1 and h=T_obs to get one long path ---
sim1 <- simulate(dcc_fit1_true, nsim = 1, h = n_state1)
sim2 <- simulate(dcc_fit2_true, nsim = 1, h = n_state2)
# --- END FIX ---

innovations <- matrix(0, nrow = T_obs, ncol = k_vars)
# --- FIX: Reshape the row-vector output from the simulation ---
sim1_series_mat <- t(rbind(as.matrix(sim1$garch_sim[[1]]$series), as.matrix(sim1$garch_sim[[2]]$series)))
sim2_series_mat <- t(rbind(as.matrix(sim2$garch_sim[[1]]$series), as.matrix(sim2$garch_sim[[2]]$series)))
# --- END FIX ---

innovations[states == 1, ] <- sim1_series_mat
innovations[states == 2, ] <- sim2_series_mat


for (t in 2:T_obs) {
  x_lagged <- c(1, y[t-1, 1], y[t-1, 2])
  if (states[t] == 1) {
    y[t, ] <- t(beta1_true) %*% x_lagged + innovations[t, ]
  } else {
    y[t, ] <- t(beta2_true) %*% x_lagged + innovations[t, ]
  }
}


# --- 3. Define Model Specification for Fitting ---
spec <- list()
dummy_mv_y_short <- xts::xts(matrix(rnorm(100 * k_vars), ncol = k_vars), order.by = Sys.Date()-(100:1))
# Define a placeholder estimated GARCH model for the spec
garch_model_est <- to_multi_estimate(list(
    estimate(tsgarch::garch_modelspec(y=dummy_mv_y_short[,1], garch_order = c(1,1)), keep_tmb = TRUE),
    estimate(tsgarch::garch_modelspec(y=dummy_mv_y_short[,2], garch_order = c(1,1)), keep_tmb = TRUE)
))


# State 1 spec
spec[[1]] <- list(
  var_order = 1,
  garch_spec_fun = "dcc_modelspec",
  garch_spec_args = list(
      garch_model = garch_model_est, # Pass the pre-estimated object
      dcc_order = c(1,1),
      distribution = "mvt"
  ),
  start_pars = list(
    var_pars = as.vector(beta1_true * 0.8),
    garch_pars = list(dcc_alpha = 0.05, dcc_beta = 0.90)
  )
)

# State 2 spec
spec[[2]] <- list(
  var_order = 1,
  garch_spec_fun = "dcc_modelspec",
  garch_spec_args = list(
      garch_model = garch_model_est, # Pass the pre-estimated object
      dcc_order = c(1,1),
      distribution = "mvt"
  ),
  start_pars = list(
    var_pars = as.vector(beta2_true * 0.8),
    garch_pars = list(dcc_alpha = 0.1, dcc_beta = 0.8)
  )
)


# --- 4. Run the Fitter ---
message("Starting the MULTIVARIATE MS-VAR-GARCH model fitting...")

control_params <- list(max_iter = 5, tol = 1e-5)

fit_results <- fit_ms_varma_garch_cpp(
  y = y,
  M = 2,
  spec = spec,
  model_type = "multivariate",
  control = control_params
)

message("Fitting complete.")


# --- 5. Print Results ---
print("--- MULTIVARIATE MS-VAR-GARCH Model Fit Results ---")
print("Estimated Transition Matrix (P):")
print(fit_results$P)

print("Final Log-Likelihood:")
print(fit_results$log_likelihood)

print("True parameters for State 1:")
print(beta1_true)

print(spec[[1]]$start_pars$garch_pars)

print("Estimated Parameters for State 1:")
print("VAR coeffs:")
print(matrix(fit_results$model_fits[[1]]$var_pars, nrow = 3, byrow = FALSE))
print(fit_results$model_fits[[1]]$garch_pars)

print("True parameters for State 2:")
print(beta2_true)

print(spec[[2]]$start_pars$garch_pars)

print("Estimated Parameters for State 2:")
print("VAR coeffs:")
print(matrix(fit_results$model_fits[[2]]$var_pars, nrow = 3, byrow = FALSE))
print(fit_results$model_fits[[2]]$garch_pars)

# Print a summary of captured warnings
warning_count <- length(unlist(fit_results$warnings))
message(paste("\nTotal warnings captured during GARCH estimation:", warning_count))

# Compare smoothed probabilities to true states
plot(fit_results$smoothed_probabilities[,1], type = 'l', col = 'blue', ylim = c(0,1), ylab = "Probability", main = "Smoothed Probability of State 1")
lines(states-1, col = 'red', lty = 2)
legend("topright", legend = c("Smoothed Prob (State 1)", "True State (1)"), col = c("blue", "red"), lty = 1:2)


```




