
# PART 8 tests
## Test 8a: Test that "DCC estimation completes without errors"

Run tests from test-ms_varma_garch_bs.R, PART 8 with diagnostics.

```{r}
#test_that("DCC estimation completes without errors", {
  
  set.seed(999)
  n <- 200  # Increased for more stable estimation
  k <- 2
  
  ## Use simulate_dcc_garch() for realistic test data with DCC dynamics
  y_test <- simulate_dcc_garch(
    n = n,
    k = k,
    omega = c(0.05, 0.08),
    alpha_garch = c(0.10, 0.12),
    beta_garch = c(0.85, 0.82),
    dcc_alpha = 0.04,
    dcc_beta = 0.93,
    seed = 999
  )
  
  colnames(y_test) <- c("s1", "s2")
  
  spec_test <- list(
    # State 1: Lower volatility
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1),
        dynamics = "dcc"  # ← CRITICAL: Specify DCC dynamics!
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0.05, k * (1 + k * 1)),  # Small but non-zero
        garch_pars = list(
          list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85),
          list(omega = 0.05, alpha1 = 0.08, beta1 = 0.85)
        ),
        dcc_pars = list(alpha_1 = 0.03, beta_1 = 0.94),
        dist_pars = NULL  # Use NULL instead of list() for clarity
      )
    ),
    # State 2: Higher volatility (differentiated starting values)
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1),
        dynamics = "dcc"  # ← CRITICAL: Specify DCC dynamics!
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0.05, k * (1 + k * 1)),
        garch_pars = list(
          list(omega = 0.12, alpha1 = 0.15, beta1 = 0.75),  # Different from State 1
          list(omega = 0.12, alpha1 = 0.15, beta1 = 0.75)
        ),
        dcc_pars = list(alpha_1 = 0.08, beta_1 = 0.88),  # Different from State 1
        dist_pars = NULL
      )
    )
  )
  
  cat("\n=== TEST 8a: Basic Functionality ===\n")
  
  # Run estimation - testthat automatically catches errors
  fit <- fit_ms_varma_garch(
    y = y_test,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 20, tol = 1e-3),
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "../output/verbose_test_8a.log"
  )
  
  # Test the results
  # expect_true(is.list(fit))
  # expect_named(fit, c("model_fits", "P", "log_likelihood", 
  #                     "smoothed_probabilities", "convergence", 
  #                     "warnings", "diagnostics"),
  #              ignore.order = TRUE, ignore.extra = TRUE)
  # expect_length(fit$model_fits, 2)
  # expect_true(is.finite(fit$log_likelihood))
  # expect_true(!is.null(fit$diagnostics))
  # Test the results
  expect_type(fit, "list")
  
  # Check essential components exist
  expect_true("model_fits" %in% names(fit))
  expect_true("P" %in% names(fit))
  expect_true("log_likelihood" %in% names(fit))
  expect_true("diagnostics" %in% names(fit))
  
  # Test properties
  expect_length(fit$model_fits, 2)
  expect_true(is.finite(fit$log_likelihood))
  expect_true(!is.null(fit$diagnostics))
  
  # Check diagnostics
  summary(fit$diagnostics)
  
  cat("Test completed successfully\n")
##})
```

Q1: Did it actually converge? No, it hit `max_iter` before converging.
```{r}
conv_check <- check_convergence(fit$diagnostics, tolerance = 1e-3)
print(conv_check)
```


Q2: What's happening in the problematic iterations?
Let's look at iteration 8 (worst in middle) and iteration 20 (worst overall):

```{r}
# Iteration 8 - large decrease
iter8 <- analyze_iteration(fit$diagnostics, 8)
print(iter8$log_likelihood)
print(iter8$warnings)

# Iteration 20 - final decrease  
iter20 <- analyze_iteration(fit$diagnostics, 20)
print(iter20$log_likelihood)
print(iter20$warnings)
```

Q3: Are parameters oscillating?
```{r}
# Check DCC alpha for state 1
alpha_traj <- extract_param_trajectory(fit$diagnostics, state = 1, param_name = "alpha_1")
print(alpha_traj$value)
```


```{r}
plot(alpha_traj$iteration, alpha_traj$value, type = "b", 
     main = "DCC Alpha Evolution - State 1",
     xlab = "Iteration", ylab = "alpha_1")
```




## Test 8b: Test that "Single regime data converges quickly (both states identical or constant)"


```{r}
##test_that("Single regime data converges quickly (both states identical or constant)", {
  
  set.seed(123)
  n <- 200
  k <- 2
  
  ## Helper function to check if parameter is at lower bound (constant correlation)
  is_constant_correlation <- function(pars) {
    alpha <- pars$alpha_1
    if (is.null(alpha)) return(TRUE)
    if (!is.null(pars$correlation_type) && pars$correlation_type == "constant") return(TRUE)
    if (alpha < 0.02) return(TRUE)
    return(FALSE)
  }
  
  ## True GARCH parameters (single regime)
  omega_true <- c(0.1, 0.15)
  alpha_true <- c(0.1, 0.12)
  beta_true <- c(0.8, 0.75)
  
  ## Simulate GARCH series (no regime switching)
  y_sim <- matrix(0, n, k)
  h <- matrix(0, n, k)
  
  for (i in 1:k) {
    h[1, i] <- omega_true[i] / (1 - alpha_true[i] - beta_true[i])
    y_sim[1, i] <- rnorm(1) * sqrt(h[1, i])
    
    for (t in 2:n) {
      h[t, i] <- omega_true[i] + alpha_true[i] * y_sim[t-1, i]^2 + 
        beta_true[i] * h[t-1, i]
      y_sim[t, i] <- rnorm(1) * sqrt(h[t, i])
    }
  }
  
  colnames(y_sim) <- c("s1", "s2")
  
  ## Create DCC specification
  spec_dcc <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, k * (1 + k * 1)),
        garch_pars = list(
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8),
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8)
        ),
        dcc_pars = list(alpha_1 = 0.05, beta_1 = 0.90),
        dist_pars = list()
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, k * (1 + k * 1)),
        garch_pars = list(
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8),
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8)
        ),
        dcc_pars = list(alpha_1 = 0.10, beta_1 = 0.85),
        dist_pars = list()
      )
    )
  )
  
  ## Fit model
  cat("\n=== TEST 8b: Single Regime Data ===\n")
  fit <- fit_ms_varma_garch(
    y = y_sim,
    M = 2,
    spec = spec_dcc,
    model_type = "multivariate",
    control = list(max_iter = 20, tol = 0.05),
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "../output/verbose_test_8b.log"
  )
  
  ## Check that fit returned something
  expect_true(!is.null(fit))
  expect_true("model_fits" %in% names(fit))
  
  ## Extract parameters from model_fits
  state1_pars <- fit$model_fits[[1]]
  state2_pars <- fit$model_fits[[2]]
  
  cat("\n=== Estimated Parameters ===\n")
  cat("\nState 1:\n")
  print(str(state1_pars, max.level = 3))
  cat("\nState 2:\n")
  print(str(state2_pars, max.level = 3))
  
  ## Check that states are either:
  ## 1. Nearly identical, OR
  ## 2. One/both have constant correlation
  state1_alpha <- state1_pars$alpha_1 %||% NULL
  state2_alpha <- state2_pars$alpha_1 %||% NULL
  
  state1_is_constant <- is_constant_correlation(state1_pars)
  state2_is_constant <- is_constant_correlation(state2_pars)
  
  states_similar <- !state1_is_constant && !state2_is_constant && 
    !is.null(state1_alpha) && !is.null(state2_alpha) &&
    abs(state1_alpha - state2_alpha) < 0.05
  
  cat("\nState 1 constant?", state1_is_constant, "\n")
  cat("State 2 constant?", state2_is_constant, "\n")
  cat("States similar?", states_similar, "\n")
  
  expect_true(state1_is_constant || state2_is_constant || states_similar,
              info = "States should be constant or nearly identical for single-regime data")
  
  # Check diagnostics
  summary(fit$diagnostics)
##})
```


## Test 8c: Test that "Mixed regime data: one dynamic, one constant correlation"

```{r}
##test_that("Mixed regime data: one dynamic, one constant correlation", {
  
  set.seed(789)
  n <- 250
  k <- 2
  
  ## STATE-DEPENDENT PARAMETERS
  ## State 1: Dynamic correlation
  omega_1 <- c(0.08, 0.12)
  alpha_garch_1 <- c(0.10, 0.12)
  beta_garch_1 <- c(0.85, 0.83)
  
  ## State 2: Higher volatility
  omega_2 <- c(0.12, 0.15)
  alpha_garch_2 <- c(0.14, 0.16)
  beta_garch_2 <- c(0.78, 0.76)
  
  ## Generate switching states
  P <- matrix(c(0.93, 0.07,
                0.15, 0.85), nrow = 2, byrow = TRUE)
  
  states <- numeric(n)
  states[1] <- 1
  for (t in 2:n) {
    states[t] <- sample(1:2, 1, prob = P[states[t-1], ])
  }
  
  ## Simulate
  y_mixed <- matrix(0, n, k)
  h_mixed <- matrix(0, n, k)
  
  for (i in 1:k) {
    h_mixed[1, i] <- 0.1
    y_mixed[1, i] <- rnorm(1) * sqrt(h_mixed[1, i])
    
    for (t in 2:n) {
      s <- states[t]
      omega <- if(s == 1) omega_1[i] else omega_2[i]
      alpha <- if(s == 1) alpha_garch_1[i] else alpha_garch_2[i]
      beta <- if(s == 1) beta_garch_1[i] else beta_garch_2[i]
      
      h_mixed[t, i] <- omega + alpha * y_mixed[t-1, i]^2 + beta * h_mixed[t-1, i]
      y_mixed[t, i] <- rnorm(1) * sqrt(h_mixed[t, i])
    }
  }
  
  colnames(y_mixed) <- c("s1", "s2")
  
  cat("\n=== TEST 8c: Mixed Regime Data ===\n")
  cat("True state distribution:\n")
  print(table(states))
  
  ## Create specification
  spec_mixed <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, k * (1 + k * 1)),
        garch_pars = list(
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8),
          list(omega = 0.1, alpha1 = 0.1, beta1 = 0.8)
        ),
        dcc_pars = list(alpha_1 = 0.05, beta_1 = 0.90),
        dist_pars = list()
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, k * (1 + k * 1)),
        garch_pars = list(
          list(omega = 0.12, alpha1 = 0.12, beta1 = 0.8),
          list(omega = 0.12, alpha1 = 0.12, beta1 = 0.8)
        ),
        dcc_pars = list(alpha_1 = 0.10, beta_1 = 0.85),
        dist_pars = list()
      )
    )
  )
  
  ## Fit model
  fit <- fit_ms_varma_garch(
    y = y_mixed,
    M = 2,
    spec = spec_mixed,
    model_type = "multivariate",
    control = list(max_iter = 50, tol = 0.05),
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "../output/verbose_test_8c.log"
  )
  
  expect_true(!is.null(fit))
  expect_true("model_fits" %in% names(fit))
  
  ## Extract parameters
  state1_pars <- fit$model_fits[[1]]
  state2_pars <- fit$model_fits[[2]]
  
  cat("\n=== ESTIMATED PARAMETERS (MIXED) ===\n")
  cat("\nState 1:\n")
  cat("  DCC: alpha=", state1_pars$alpha_1 %||% "constant", 
      " beta=", state1_pars$beta_1 %||% "N/A", "\n")
  cat("  Type:", state1_pars$correlation_type %||% "inferred", "\n")
  
  cat("\nState 2:\n")
  cat("  DCC: alpha=", state2_pars$alpha_1 %||% "constant", 
      " beta=", state2_pars$beta_1 %||% "N/A", "\n")
  cat("  Type:", state2_pars$correlation_type %||% "inferred", "\n")
  
  ## Just verify both states have valid structures
  expect_true(!is.null(state1_pars$garch_pars))
  expect_true(!is.null(state2_pars$garch_pars))
  
  # Check diagnostics
  summary(fit$diagnostics)
##})
```




## Test 8d: Test that "True MS-DCC-GARCH data recovers distinct regimes"

WARNING: This test may take hours!

```{r}
#test_that("True MS-DCC-GARCH data recovers distinct regimes", {
  skip_on_cran()
  
  
  simulate_ms_dcc_garch <- function(n, k = 2, seed = 456) {
    set.seed(seed)
    
    ## STATE-DEPENDENT PARAMETERS
    ## State 1: Low volatility, low correlation dynamics
    omega_1 <- c(0.05, 0.08)
    alpha_garch_1 <- c(0.08, 0.10)
    beta_garch_1 <- c(0.85, 0.80)
    dcc_alpha_1 <- 0.03
    dcc_beta_1 <- 0.94
    Rbar_1 <- matrix(c(1, 0.3, 0.3, 1), 2, 2)  # Lower correlation
    
    ## State 2: High volatility, high correlation dynamics  
    omega_2 <- c(0.15, 0.20)
    alpha_garch_2 <- c(0.15, 0.18)
    beta_garch_2 <- c(0.70, 0.65)
    dcc_alpha_2 <- 0.12
    dcc_beta_2 <- 0.83
    Rbar_2 <- matrix(c(1, 0.7, 0.7, 1), 2, 2)  # Higher correlation
    
    ## Markov chain switching probabilities
    P <- matrix(c(0.95, 0.05,   # P(stay in 1), P(1->2)
                  0.10, 0.90),  # P(2->1), P(stay in 2)
                nrow = 2, byrow = TRUE)
    
    ## Generate state sequence
    states <- numeric(n)
    states[1] <- 1
    for (t in 2:n) {
      states[t] <- sample(1:2, 1, prob = P[states[t-1], ])
    }
    
    ## Initialize
    y_ms <- matrix(0, n, k)
    h_ms <- matrix(0, n, k)
    z_std <- matrix(0, n, k)  # Standardized residuals
    
    ## Initialize conditional variances
    for (i in 1:k) {
      h_ms[1, i] <- omega_1[i] / (1 - alpha_garch_1[i] - beta_garch_1[i])
    }
    
    ## Initialize DCC matrices for each state
    Q_1 <- Rbar_1
    R_1 <- Rbar_1
    Q_2 <- Rbar_2
    R_2 <- Rbar_2
    
    ## Simulate
    for (t in 1:n) {
      s <- states[t]
      
      ## Select state-specific parameters
      omega <- if(s == 1) omega_1 else omega_2
      alpha_garch <- if(s == 1) alpha_garch_1 else alpha_garch_2
      beta_garch <- if(s == 1) beta_garch_1 else beta_garch_2
      dcc_alpha <- if(s == 1) dcc_alpha_1 else dcc_alpha_2
      dcc_beta <- if(s == 1) dcc_beta_1 else dcc_beta_2
      Rbar <- if(s == 1) Rbar_1 else Rbar_2
      
      ## Get current correlation matrix
      if (s == 1) {
        R_t <- R_1
      } else {
        R_t <- R_2
      }
      
      ## Draw CORRELATED standardized residuals
      z_std[t, ] <- mvtnorm::rmvnorm(1, mean = rep(0, k), sigma = R_t)
      
      ## Compute conditional variances and raw residuals
      for (i in 1:k) {
        if (t > 1) {
          h_ms[t, i] <- omega[i] + alpha_garch[i] * y_ms[t-1, i]^2 + 
            beta_garch[i] * h_ms[t-1, i]
        }
        y_ms[t, i] <- sqrt(h_ms[t, i]) * z_std[t, i]
      }
      
      ## Update DCC dynamics for NEXT period
      if (t < n) {
        z_lag <- matrix(z_std[t, ], ncol = 1)
        
        if (states[t+1] == 1) {
          ## Update State 1 DCC
          Q_1 <- Rbar_1 * (1 - dcc_alpha_1 - dcc_beta_1) + 
            dcc_alpha_1 * (z_lag %*% t(z_lag)) + 
            dcc_beta_1 * Q_1
          
          ## Standardize to correlation
          Q_diag_inv_sqrt <- diag(1 / sqrt(diag(Q_1)), k)
          R_1 <- Q_diag_inv_sqrt %*% Q_1 %*% Q_diag_inv_sqrt
          
        } else {
          ## Update State 2 DCC
          Q_2 <- Rbar_2 * (1 - dcc_alpha_2 - dcc_beta_2) + 
            dcc_alpha_2 * (z_lag %*% t(z_lag)) + 
            dcc_beta_2 * Q_2
          
          Q_diag_inv_sqrt <- diag(1 / sqrt(diag(Q_2)), k)
          R_2 <- Q_diag_inv_sqrt %*% Q_2 %*% Q_diag_inv_sqrt
        }
      }
    }
    
    colnames(y_ms) <- paste0("s", 1:k)
    
    return(list(
      data = y_ms,
      states = states,
      h = h_ms,
      z_std = z_std,
      true_params = list(
        state1 = list(
          omega = omega_1,
          alpha_garch = alpha_garch_1,
          beta_garch = beta_garch_1,
          dcc_alpha = dcc_alpha_1,
          dcc_beta = dcc_beta_1,
          Rbar = Rbar_1
        ),
        state2 = list(
          omega = omega_2,
          alpha_garch = alpha_garch_2,
          beta_garch = beta_garch_2,
          dcc_alpha = dcc_alpha_2,
          dcc_beta = dcc_beta_2,
          Rbar = Rbar_2
        )
      )
    ))
  }
  
  ## Generate proper MS-DCC data
  sim_data <- simulate_ms_dcc_garch(n = 300, k = 2, seed = 456)
  
  y_ms <- sim_data$data
  states_true <- sim_data$states
  
  cat("\n=== TEST: True MS-DCC Data (PROPERLY SIMULATED) ===\n")
  cat("True state distribution:\n")
  print(table(states_true))
  
  ## Check that correlation exists in the data
  cor_s1 <- cor(y_ms[, 1], y_ms[, 2])
  cat("Sample correlation:", cor_s1, "\n")
  
  ## Create specification with DISTINCT starting values
  spec_ms_dcc <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, 2 * (1 + 2 * 1)),
        garch_pars = list(
          list(omega = 0.06, alpha1 = 0.08, beta1 = 0.85),
          list(omega = 0.09, alpha1 = 0.10, beta1 = 0.80)
        ),
        dcc_pars = list(alpha_1 = 0.04, beta_1 = 0.93),
        dist_pars = list()
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      garch_spec_args = list(
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        ),
        dcc_order = c(1, 1)
      ),
      distribution = "mvn",
      start_pars = list(
        var_pars = rep(0, 2 * (1 + 2 * 1)),
        garch_pars = list(
          list(omega = 0.16, alpha1 = 0.16, beta1 = 0.68),
          list(omega = 0.21, alpha1 = 0.19, beta1 = 0.63)
        ),
        dcc_pars = list(alpha_1 = 0.13, beta_1 = 0.82),
        dist_pars = list()
      )
    )
  )
  
  ## Fit model
  fit <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_ms_dcc,
    model_type = "multivariate",
    control = list(max_iter = 50, tol = 0.05),
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "../output/verbose_test_8d.log"
  )
  
  ## Verify structure
  expect_true(!is.null(fit))
  expect_true("model_fits" %in% names(fit))
  
  ## Extract parameters
  state1_pars <- fit$model_fits[[1]]
  state2_pars <- fit$model_fits[[2]]
  
  cat("\n=== ESTIMATED PARAMETERS ===\n")
  cat("\nState 1:\n")
  if (!is.null(state1_pars$garch_pars)) {
    cat("  GARCH series 1: omega=", state1_pars$garch_pars[[1]]$omega,
        " alpha=", state1_pars$garch_pars[[1]]$alpha1,
        " beta=", state1_pars$garch_pars[[1]]$beta1, "\n")
  }
  cat("  DCC: alpha=", state1_pars$alpha_1 %||% "constant", 
      " beta=", state1_pars$beta_1 %||% "N/A", "\n")
  cat("  Type:", state1_pars$correlation_type %||% "unknown", "\n")
  
  cat("\nState 2:\n")
  if (!is.null(state2_pars$garch_pars)) {
    cat("  GARCH series 1: omega=", state2_pars$garch_pars[[1]]$omega,
        " alpha=", state2_pars$garch_pars[[1]]$alpha1,
        " beta=", state2_pars$garch_pars[[1]]$beta1, "\n")
  }
  cat("  DCC: alpha=", state2_pars$alpha_1 %||% "constant", 
      " beta=", state2_pars$beta_1 %||% "N/A", "\n")
  cat("  Type:", state2_pars$correlation_type %||% "unknown", "\n")
  
  ## Now with proper DCC simulation, both states should have dynamic correlation
  ## (or at least one should, depending on estimation)
  
  ## Basic validity checks
  expect_true(!is.null(state1_pars$garch_pars))
  expect_true(!is.null(state2_pars$garch_pars))
  
  ## Check that states differ
  if (!is.null(state1_pars$garch_pars) && !is.null(state2_pars$garch_pars)) {
    omega_diff <- abs(state1_pars$garch_pars[[1]]$omega - 
                        state2_pars$garch_pars[[1]]$omega)
    expect_true(omega_diff > 0.02,
                info = "States should have different volatility parameters")
  }
  
  # Check diagnostics
  summary(fit$diagnostics)
#})
```




## Other diagnostic tests

```{r}
test_that("DIAGNOSTIC: Convergence criteria and tolerance analysis", {
  skip_on_cran()
  
  cat("\n=== CONVERGENCE CRITERIA DIAGNOSTIC ===\n")
  
  ## Simulate proper 2-state MS-DCC-GARCH data
  set.seed(456)
  n <- 300
  k <- 2
  
  ## STATE-DEPENDENT PARAMETERS (clearly different states)
  ## State 1: Low volatility, low correlation
  omega_1 <- c(0.05, 0.08)
  alpha_garch_1 <- c(0.08, 0.10)
  beta_garch_1 <- c(0.85, 0.80)
  
  ## State 2: High volatility, high correlation  
  omega_2 <- c(0.15, 0.20)
  alpha_garch_2 <- c(0.15, 0.18)
  beta_garch_2 <- c(0.70, 0.65)
  
  ## Markov switching
  P <- matrix(c(0.95, 0.05,   # P(stay in 1), P(1->2)
                0.10, 0.90),  # P(2->1), P(stay in 2)
              nrow = 2, byrow = TRUE)
  
  ## Generate state sequence
  states <- numeric(n)
  states[1] <- 1
  for (t in 2:n) {
    states[t] <- sample(1:2, 1, prob = P[states[t-1], ])
  }
  
  ## Simulate
  y_ms <- matrix(0, n, k)
  h_ms <- matrix(0, n, k)
  
  for (i in 1:k) {
    h_ms[1, i] <- 0.1
    y_ms[1, i] <- rnorm(1) * sqrt(h_ms[1, i])
    
    for (t in 2:n) {
      s <- states[t]
      omega <- if(s == 1) omega_1[i] else omega_2[i]
      alpha <- if(s == 1) alpha_garch_1[i] else alpha_garch_2[i]
      beta <- if(s == 1) beta_garch_1[i] else beta_garch_2[i]
      
      h_ms[t, i] <- omega + alpha * y_ms[t-1, i]^2 + beta * h_ms[t-1, i]
      y_ms[t, i] <- rnorm(1) * sqrt(h_ms[t, i])
    }
  }
  
  colnames(y_ms) <- c("s1", "s2")
  
  cat("True state distribution:\n")
  print(table(states))
  cat("\n")
  
  ## Create specification
  spec_test <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.06, alpha1 = 0.08, beta1 = 0.85),
          list(omega = 0.09, alpha1 = 0.10, beta1 = 0.80)
        ),
        dcc_pars = list(alpha_1 = 0.04, beta_1 = 0.93)
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.16, alpha1 = 0.16, beta1 = 0.68),
          list(omega = 0.21, alpha1 = 0.19, beta1 = 0.63)
        ),
        dcc_pars = list(alpha_1 = 0.13, beta_1 = 0.82)
      )
    )
  )
  
  ## ========================================================================
  ## FIT 1: Strict tolerance (0.001)
  ## ========================================================================
  cat("\n--- Fitting with STRICT tolerance (tol=0.001) ---\n")
  
  fit_strict <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 100, tol = 0.001),
    collect_diagnostics = TRUE,
    verbose = FALSE
  )
  
  ## ========================================================================
  ## FIT 2: Relaxed tolerance (0.05)
  ## ========================================================================
  cat("\n--- Fitting with RELAXED tolerance (tol=0.05) ---\n")
  
  fit_relaxed <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 100, tol = 0.05),
    collect_diagnostics = TRUE,
    verbose = FALSE
  )
  
  ## ========================================================================
  ## FIT 3: Very strict (0.0001) - to see if we can ever converge
  ## ========================================================================
  cat("\n--- Fitting with VERY STRICT tolerance (tol=0.0001) ---\n")
  
  fit_very_strict <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 100, tol = 0.0001),
    collect_diagnostics = TRUE,
    verbose = FALSE
  )
  
  ## ========================================================================
  ## ANALYSIS
  ## ========================================================================
  
  cat("\n=== CONVERGENCE COMPARISON ===\n\n")
  
  ## Extract metrics
  analyze_convergence <- function(fit, label) {
    n_iter <- length(fit$diagnostics$em_iterations)
    
    ll_initial <- fit$diagnostics$em_iterations[[1]]$log_lik_before_mstep
    ll_final <- fit$diagnostics$em_iterations[[n_iter]]$log_lik_after_mstep
    ll_improvement <- ll_final - ll_initial
    
    ll_changes <- sapply(fit$diagnostics$em_iterations, function(x) x$ll_change)
    
    # Check if converged or hit max_iter
    last_change <- ll_changes[length(ll_changes)]
    converged <- n_iter < 100  # Didn't hit max_iter
    
    # Total time
    total_time <- sum(sapply(fit$diagnostics$em_iterations, function(x) x$duration_seconds))
    
    list(
      label = label,
      n_iter = n_iter,
      ll_initial = ll_initial,
      ll_final = ll_final,
      ll_improvement = ll_improvement,
      ll_changes = ll_changes,
      last_change = last_change,
      converged = converged,
      total_time = total_time
    )
  }
  
  results_strict <- analyze_convergence(fit_strict, "Strict (tol=0.001)")
  results_relaxed <- analyze_convergence(fit_relaxed, "Relaxed (tol=0.05)")
  results_very_strict <- analyze_convergence(fit_very_strict, "Very Strict (tol=0.0001)")
  
  ## Print comparison
  print_results <- function(r) {
    cat(r$label, ":\n")
    cat("  Iterations:", r$n_iter, if(r$converged) "(converged)" else "(hit max_iter)", "\n")
    cat("  Initial LL:", round(r$ll_initial, 2), "\n")
    cat("  Final LL:", round(r$ll_final, 2), "\n")
    cat("  Total improvement:", round(r$ll_improvement, 4), "\n")
    cat("  Last LL change:", round(r$last_change, 6), "\n")
    cat("  Time:", round(r$total_time, 1), "seconds\n")
    cat("  LL decreased in", sum(r$ll_changes < 0), "iterations\n\n")
  }
  
  print_results(results_strict)
  print_results(results_relaxed)
  print_results(results_very_strict)
  
  ## ========================================================================
  ## Compare final parameter estimates
  ## ========================================================================
  
  cat("=== PARAMETER COMPARISON ===\n\n")
  
  # Compare omega from state 1, series 1
  omega_strict <- fit_strict$model_fits[[1]]$garch_pars[[1]]$omega
  omega_relaxed <- fit_relaxed$model_fits[[1]]$garch_pars[[1]]$omega
  omega_very_strict <- fit_very_strict$model_fits[[1]]$garch_pars[[1]]$omega
  
  cat("State 1, Series 1, omega:\n")
  cat("  Strict:", round(omega_strict, 6), "\n")
  cat("  Relaxed:", round(omega_relaxed, 6), "\n")
  cat("  Very Strict:", round(omega_very_strict, 6), "\n")
  cat("  Difference (strict vs relaxed):", round(abs(omega_strict - omega_relaxed), 6), "\n")
  cat("  Difference (strict vs very_strict):", round(abs(omega_strict - omega_very_strict), 6), "\n\n")
  
  # Compare DCC alpha from state 1
  alpha_strict <- fit_strict$model_fits[[1]]$alpha_1 %||% NA
  alpha_relaxed <- fit_relaxed$model_fits[[1]]$alpha_1 %||% NA
  alpha_very_strict <- fit_very_strict$model_fits[[1]]$alpha_1 %||% NA
  
  cat("State 1, DCC alpha_1:\n")
  cat("  Strict:", round(alpha_strict, 6), "\n")
  cat("  Relaxed:", round(alpha_relaxed, 6), "\n")
  cat("  Very Strict:", round(alpha_very_strict, 6), "\n")
  if (!is.na(alpha_strict) && !is.na(alpha_relaxed)) {
    cat("  Difference (strict vs relaxed):", round(abs(alpha_strict - alpha_relaxed), 6), "\n")
  }
  if (!is.na(alpha_strict) && !is.na(alpha_very_strict)) {
    cat("  Difference (strict vs very_strict):", round(abs(alpha_strict - alpha_very_strict), 6), "\n")
  }
  cat("\n")
  
  ## ========================================================================
  ## Compare log-likelihood values
  ## ========================================================================
  
  cat("=== LOG-LIKELIHOOD COMPARISON ===\n\n")
  
  ll_diff_relaxed <- abs(results_relaxed$ll_final - results_strict$ll_final)
  ll_diff_very_strict <- abs(results_very_strict$ll_final - results_strict$ll_final)
  
  cat("Final LL difference (strict vs relaxed):", round(ll_diff_relaxed, 6), "\n")
  cat("Final LL difference (strict vs very_strict):", round(ll_diff_very_strict, 6), "\n")
  cat("Is relaxed 'close enough'?", ll_diff_relaxed < 0.1, "\n")
  cat("Relative difference:", round(ll_diff_relaxed / abs(results_strict$ll_final) * 100, 4), "%\n\n")
  
  ## ========================================================================
  ## Visualize LL evolution
  ## ========================================================================
  
  cat("=== LL EVOLUTION (last 10 iterations) ===\n\n")
  
  show_tail <- function(r, n = 10) {
    start_idx <- max(1, length(r$ll_changes) - n + 1)
    tail_changes <- r$ll_changes[start_idx:length(r$ll_changes)]
    cat(r$label, ":\n")
    cat("  Changes:", paste(round(tail_changes, 6), collapse = ", "), "\n\n")
  }
  
  show_tail(results_strict)
  show_tail(results_relaxed)
  show_tail(results_very_strict)
  
  ## ========================================================================
  ## TESTS
  ## ========================================================================
  
  ## Test 1: All should produce finite LL
  expect_true(is.finite(fit_strict$log_likelihood))
  expect_true(is.finite(fit_relaxed$log_likelihood))
  expect_true(is.finite(fit_very_strict$log_likelihood))
  
  ## Test 2: Relaxed should stop earlier (fewer iterations)
  expect_true(results_relaxed$n_iter <= results_strict$n_iter,
              info = "Relaxed tolerance should require fewer iterations")
  
  ## Test 3: Final LL should be very close despite different tolerance
  expect_true(ll_diff_relaxed < 1.0,
              info = paste("Final LL should be similar. Difference:", ll_diff_relaxed))
  
  ## Test 4: Parameter estimates should be close
  param_diff <- abs(omega_strict - omega_relaxed)
  expect_true(param_diff < 0.01,
              info = paste("Parameter estimates should be similar. Omega difference:", param_diff))
  
  ## Test 5: Relaxed should save substantial time
  time_saved <- results_strict$total_time - results_relaxed$total_time
  time_saved_pct <- time_saved / results_strict$total_time * 100
  cat("Time saved with relaxed tolerance:", round(time_saved, 1), 
      "seconds (", round(time_saved_pct, 1), "%)\n")
  
  ## CONCLUSION
  cat("\n=== CONCLUSION ===\n")
  cat("Based on this analysis:\n")
  if (ll_diff_relaxed < 0.1 && param_diff < 0.01) {
    cat("✓ tol=0.05 appears APPROPRIATE for LL in the hundreds\n")
    cat("✓ Final estimates are nearly identical\n")
    cat("✓ Substantial time savings with relaxed tolerance\n")
  } else if (ll_diff_relaxed < 1.0) {
    cat("~ tol=0.05 may be slightly too relaxed but still reasonable\n")
    cat("  Consider tol=0.01 as a middle ground\n")
  } else {
    cat("✗ tol=0.05 may be too relaxed - final estimates differ substantially\n")
    cat("  Recommend stricter tolerance\n")
  }
})
```

```{r}
test_that("DIAGNOSTIC: Detailed M-step analysis with beta near zero", {
  skip_on_cran()
  
  cat("\n=== ANALYZING M-STEP WITH BETA LOWER BOUND = 1e-6 ===\n")
  cat("This will show us WHY beta converges to zero\n\n")
  
  ## Simulate proper 2-state MS-DCC-GARCH data
  set.seed(456)
  n <- 300
  k <- 2
  
  ## STATE-DEPENDENT PARAMETERS (clearly different states)
  ## State 1: Low volatility, low correlation
  omega_1 <- c(0.05, 0.08)
  alpha_garch_1 <- c(0.08, 0.10)
  beta_garch_1 <- c(0.85, 0.80)
  
  ## State 2: High volatility, high correlation  
  omega_2 <- c(0.15, 0.20)
  alpha_garch_2 <- c(0.15, 0.18)
  beta_garch_2 <- c(0.70, 0.65)
  
  ## Markov switching
  P <- matrix(c(0.95, 0.05,   # P(stay in 1), P(1->2)
                0.10, 0.90),  # P(2->1), P(stay in 2)
              nrow = 2, byrow = TRUE)
  
  ## Generate state sequence
  states <- numeric(n)
  states[1] <- 1
  for (t in 2:n) {
    states[t] <- sample(1:2, 1, prob = P[states[t-1], ])
  }
  
  ## Simulate
  y_ms <- matrix(0, n, k)
  h_ms <- matrix(0, n, k)
  
  for (i in 1:k) {
    h_ms[1, i] <- 0.1
    y_ms[1, i] <- rnorm(1) * sqrt(h_ms[1, i])
    
    for (t in 2:n) {
      s <- states[t]
      omega <- if(s == 1) omega_1[i] else omega_2[i]
      alpha <- if(s == 1) alpha_garch_1[i] else alpha_garch_2[i]
      beta <- if(s == 1) beta_garch_1[i] else beta_garch_2[i]
      
      h_ms[t, i] <- omega + alpha * y_ms[t-1, i]^2 + beta * h_ms[t-1, i]
      y_ms[t, i] <- rnorm(1) * sqrt(h_ms[t, i])
    }
  }
  
  colnames(y_ms) <- c("s1", "s2")
  
  cat("True state distribution:\n")
  print(table(states))
  cat("\n")
  
  ## Create specification
  spec_test <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.06, alpha1 = 0.08, beta1 = 0.85),
          list(omega = 0.09, alpha1 = 0.10, beta1 = 0.80)
        ),
        dcc_pars = list(alpha_1 = 0.04, beta_1 = 0.93)
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.16, alpha1 = 0.16, beta1 = 0.68),
          list(omega = 0.21, alpha1 = 0.19, beta1 = 0.63)
        ),
        dcc_pars = list(alpha_1 = 0.13, beta_1 = 0.82)
      )
    )
  )
  
  ## Run with VERBOSE to capture M-step details
  ## Only need to run until iteration 26-28 when beta=0 is established
  fit <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 28, tol = 0.001),  # Just past the problem
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "beta_zero_diagnosis.log"
  )
  
  cat("\n✓ Verbose output saved to: beta_zero_diagnosis.log\n")
  cat("✓ Fit object saved to global environment as: fit_beta_zero\n\n")
  
  ## Analyze what we captured
  ll_changes <- sapply(fit$diagnostics$em_iterations, function(x) x$ll_change)
  decrease_iters <- which(ll_changes < -1e-6)
  
  cat("=== SUMMARY ===\n")
  cat("Iterations with LL decreases:", length(decrease_iters), "\n")
  cat("Decrease iterations:", paste(decrease_iters, collapse = ", "), "\n\n")
  
  ## Check for DCC penalties
  dcc_warnings <- Filter(function(w) w$type == "dcc_penalty", 
                         fit$diagnostics$warnings)
  
  cat("DCC penalty warnings:", length(dcc_warnings), "\n")
  if (length(dcc_warnings) > 0) {
    cat("\nFirst 5 penalties:\n")
    for (w in head(dcc_warnings, 5)) {
      cat("  Iter", w$iteration, ":", w$message, "\n")
      if (!is.null(w$details)) {
        cat("    ", paste(names(w$details), "=", sapply(w$details, round, 4), 
                          collapse = ", "), "\n")
      }
    }
  }
  
  ## Check beta evolution
  cat("\n=== BETA EVOLUTION ===\n")
  for (state_num in 1:2) {
    state_key <- paste0("state_", state_num)
    state_data <- fit$diagnostics$parameter_evolution[[state_key]]
    
    cat("\nState", state_num, ":\n")
    for (iter_data in tail(state_data, 10)) {
      beta_val <- iter_data$parameters$beta_1
      alpha_val <- iter_data$parameters$alpha_1
      if (!is.null(beta_val) && !is.null(alpha_val)) {
        cat(sprintf("  Iter %2d: alpha=%.4f, beta=%.4f, sum=%.4f\n",
                    iter_data$iteration, alpha_val, beta_val, alpha_val + beta_val))
      }
    }
  }
  
  ## Save for analysis
  saveRDS(fit, "fit_beta_zero.rds")
  assign("fit_beta_zero", fit, envir = .GlobalEnv)
  
  cat("\n=== NEXT STEPS ===\n")
  cat("1. Examine beta_zero_diagnosis.log for M-step optimization details\n")
  cat("2. Look for 'DCC M-STEP DIAGNOSTIC' sections around iterations 22-26\n")
  cat("3. Check if optimizer is reporting convergence or hitting bounds\n")
  cat("4. Look for any 'Returning penalty' messages\n")
})
```



```{r}
test_that("DIAGNOSTIC: Does beta lower bound = 0.01 prevent LL decreases?", {
  skip_on_cran()
  
  cat("\n=== TESTING BETA LOWER BOUND = 0.01 ===\n")
  cat("NOTE: Change lower bound in estimate_dcc_parameters_weighted() first!\n\n")
  
  ## Simulate proper 2-state MS-DCC-GARCH data
  set.seed(456)
  n <- 300
  k <- 2
  
  ## STATE-DEPENDENT PARAMETERS (clearly different states)
  ## State 1: Low volatility, low correlation
  omega_1 <- c(0.05, 0.08)
  alpha_garch_1 <- c(0.08, 0.10)
  beta_garch_1 <- c(0.85, 0.80)
  
  ## State 2: High volatility, high correlation  
  omega_2 <- c(0.15, 0.20)
  alpha_garch_2 <- c(0.15, 0.18)
  beta_garch_2 <- c(0.70, 0.65)
  
  ## Markov switching
  P <- matrix(c(0.95, 0.05,   # P(stay in 1), P(1->2)
                0.10, 0.90),  # P(2->1), P(stay in 2)
              nrow = 2, byrow = TRUE)
  
  ## Generate state sequence
  states <- numeric(n)
  states[1] <- 1
  for (t in 2:n) {
    states[t] <- sample(1:2, 1, prob = P[states[t-1], ])
  }
  
  ## Simulate
  y_ms <- matrix(0, n, k)
  h_ms <- matrix(0, n, k)
  
  for (i in 1:k) {
    h_ms[1, i] <- 0.1
    y_ms[1, i] <- rnorm(1) * sqrt(h_ms[1, i])
    
    for (t in 2:n) {
      s <- states[t]
      omega <- if(s == 1) omega_1[i] else omega_2[i]
      alpha <- if(s == 1) alpha_garch_1[i] else alpha_garch_2[i]
      beta <- if(s == 1) beta_garch_1[i] else beta_garch_2[i]
      
      h_ms[t, i] <- omega + alpha * y_ms[t-1, i]^2 + beta * h_ms[t-1, i]
      y_ms[t, i] <- rnorm(1) * sqrt(h_ms[t, i])
    }
  }
  
  colnames(y_ms) <- c("s1", "s2")
  
  cat("True state distribution:\n")
  print(table(states))
  cat("\n")
  
  ## Create specification
  spec_test <- list(
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.06, alpha1 = 0.08, beta1 = 0.85),
          list(omega = 0.09, alpha1 = 0.10, beta1 = 0.80)
        ),
        dcc_pars = list(alpha_1 = 0.04, beta_1 = 0.93)
      )
    ),
    list(
      var_order = 1,
      garch_spec_fun = "dcc_modelspec",
      distribution = "mvn",
      garch_spec_args = list(
        dcc_order = c(1, 1),
        dynamics = "dcc",
        garch_model = list(
          univariate = list(
            list(model = "garch", garch_order = c(1, 1), distribution = "norm"),
            list(model = "garch", garch_order = c(1, 1), distribution = "norm")
          )
        )
      ),
      start_pars = list(
        var_pars = rep(0.1, 6),
        garch_pars = list(
          list(omega = 0.16, alpha1 = 0.16, beta1 = 0.68),
          list(omega = 0.21, alpha1 = 0.19, beta1 = 0.63)
        ),
        dcc_pars = list(alpha_1 = 0.13, beta_1 = 0.82)
      )
    )
  )
  
  ## Run with same settings as Test 1 for comparison
  fit <- fit_ms_varma_garch(
    y = y_ms,
    M = 2,
    spec = spec_test,
    model_type = "multivariate",
    control = list(max_iter = 28, tol = 0.001),
    collect_diagnostics = TRUE,
    verbose = TRUE,
    verbose_file = "beta_bounded_diagnosis.log"
  )
  
  ## Analyze
  ll_changes <- sapply(fit$diagnostics$em_iterations, function(x) x$ll_change)
  decrease_iters <- which(ll_changes < -1e-6)
  
  cat("=== COMPARISON ===\n")
  cat("With beta >= 0.01:\n")
  cat("  Iterations with LL decreases:", length(decrease_iters), "\n")
  
  if (length(decrease_iters) > 0) {
    cat("  Decrease iterations:", paste(decrease_iters, collapse = ", "), "\n")
    cat("  ⚠️  Problem NOT fixed by beta bound\n")
  } else {
    cat("  ✓ NO LL decreases! Problem appears to be fixed.\n")
  }
  
  ## Check final beta values
  cat("\n=== FINAL BETA VALUES ===\n")
  for (j in 1:2) {
    beta_val <- fit$model_fits[[j]]$beta_1
    alpha_val <- fit$model_fits[[j]]$alpha_1
    cat("State", j, ": alpha=", round(alpha_val %||% NA, 4), 
        ", beta=", round(beta_val %||% NA, 4), "\n")
  }
  
  saveRDS(fit, "fit_beta_bounded.rds")
  assign("fit_beta_bounded", fit, envir = .GlobalEnv)
})
```